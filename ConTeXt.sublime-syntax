%YAML 1.2
---
# See http://www.sublimetext.com/docs/3/syntax.html for a good, albeit
# incomplete, explanation of how this syntax works.
name: ConTeXt
file_extensions: tex
scope: text.tex.context
# The tricks I know to make the syntax highlighting work (in Monokai Extended):
#   'string' - (light) yellow
#   'variable.parameter' - orange, italic
#   'keyword' - red
#   'markup.bold' - red, bold
#   'markup.italic' - red, italic
#   'markup.heading' - orange
#   'constant.(other|numeric|character|...)' - purple
#   'support.function' (or 'meta.diff') - blue
#   'entity' - green
#   'comment' - grey(ed out)
# Honestly though this facet of the syntax highlighting is the one I least
# understand... looking at the scopes that come up in markdown highlighting, I
# see a lot of interesting things.
#   If I get round to adding snippets and other such fancy things to
# ConTeXtTools, then I'll have to rework this stuff.

# -----------------------------------------------------------------------------
# VARIABLES
# -----------------------------------------------------------------------------
# Variables are nice; unfortunately they can't be used everywhere (you can't
# do 'scope: {{var}}' for example). But you can use them in matches, and to do
# so you simply write {{variable_name}} inside the regex for the match. (Make
# sure to use quotes if you do use a variable - the YAML syntax generally
# doesn't mind whether you use quotes or not as long its unambiguous, but it
# will be very unhappy with you if don't quote something with a '{{var}}' in
# it.)
variables:
  # We have a copy of the builtins from the TeX Math sublime-syntax file,
  # which we use to guess whether a body of text is in math mode or not.
  math_builtin: '({{math_builtins_1}}|{{math_builtins_2}}|{{math_builtins_3}})'
  math_builtins_1:
    '(sum|prod|coprod|int|oint|bigcap|bigcup|bigsqcup|bigvee|bigwedge|bigodot|
      bigotimes|bogoplus|biguplus)'
  math_builtins_2:
    '(arccos|arcsin|arctan|arg|cos|cosh|cot|coth|csc|deg|det|dim|exp|gcd|hom|
      inf|ker|lg|lim|liminf|limsup|ln|log|max|min|pr|sec|sin|sinh|sup|tan|
      tanh)'
  math_builtins_3:
    '(s(s(earrow|warrow|lash)|h(ort(downarrow|uparrow|parallel|leftarrow|
      rightarrow|mid)|arp)|tar|i(gma|m(eq)?)|u(cc(sim|n(sim|approx)|curlyeq|eq|
      approx)?|pset(neq(q)?|plus(eq)?|eq(q)?)?|rd|m|bset(neq(q)?|plus(eq)?|eq(q
      )?)?)|p(hericalangle|adesuit)|e(tminus|arrow)|q(su(pset(eq)?|bset(eq)?)|c
      (up|ap)|uare)|warrow|m(ile|all(s(etminus|mile)|frown)))|h(slash|ook(
      leftarrow|rightarrow)|eartsuit|bar)|R(sh|ightarrow|e|bag)|Gam(e|ma)|n(s(
      hort(parallel|mid)|im|u(cc(eq)?|pseteq(q)?|bseteq))|Rightarrow|n(earrow|
      warrow)|cong|triangle(left(eq(slant)?)?|right(eq(slant)?)?)|i(plus)?|u|p
      (lus|arallel|rec(eq)?)|e(q|arrow|g|xists)|v(dash|Dash)|warrow|le(ss|q(
      slant|q)?|ft(arrow|rightarrow))|a(tural|bla)|VDash|rightarrow|g(tr|eq(
      slant|q)?)|mid|Left(arrow|rightarrow))|c(hi|irc(eq|le(d(circ|S|dash|ast)|
      arrow(left|right)))?|o(ng|prod|lon|mplement)|dot(s|p)?|u(p|r(vearrow(left
      |right)|ly(eq(succ|prec)|vee(downarrow|uparrow)?|wedge(downarrow|uparrow)
      ?)))|enterdot|lubsuit|ap)|Xi|Maps(to(char)?|from(char)?)|B(ox|umpeq|bbk)|
      t(h(ick(sim|approx)|e(ta|refore))|imes|op|wohead(leftarrow|rightarrow)|a(
      u|lloblong)|riangle(down|q|left(eq(slant)?)?|right(eq(slant)?)?)?)|i(n(t(
      er(cal|leave))?|plus|fty)?|ota|math)|S(igma|u(pset|bset))|zeta|o(slash|
      times|int|dot|plus|vee|wedge|lessthan|greaterthan|m(inus|ega)|b(slash|
      long|ar))|d(i(v(ideontimes)?|a(g(down|up)|mond(suit)?)|gamma)|o(t(plus|eq
      (dot)?)|ublebarwedge|wn(harpoon(left|right)|downarrows|arrow))|d(ots|
      agger)|elta|a(sh(v|leftarrow|rightarrow)|leth|gger))|Y(down|up|left|right
      )|C(up|ap)|u(n(lhd|rhd)|p(silon|harpoon(left|right)|downarrow|uparrows|
      lus|arrow)|lcorner|rcorner)|jmath|Theta|Im|p(si|hi|i(tchfork)?|erp|ar(
      tial|allel)|r(ime|o(d|pto)|ec(sim|n(sim|approx)|curlyeq|eq|approx)?)|m)|e
      (t(h|a)|psilon|q(slant(less|gtr)|circ|uiv)|ll|xists|mptyset)|Omega|D(
      iamond|ownarrow|elta)|v(d(ots|ash)|ee(bar)?|Dash|ar(s(igma|u(psetneq(q)?|
      bsetneq(q)?))|nothing|curly(vee|wedge)|t(heta|imes|riangle(left|right)?)|
      o(slash|circle|times|dot|plus|vee|wedge|lessthan|ast|greaterthan|minus|b(
      slash|ar))|p(hi|i|ropto)|epsilon|kappa|rho|bigcirc))|kappa|Up(silon|
      downarrow|arrow)|Join|f(orall|lat|a(t(s(emi|lash)|bslash)|llingdotseq)|
      rown)|P(si|hi|i)|w(p|edge|r)|l(hd|n(sim|eq(q)?|approx)|ceil|times|
      ightning|o(ng(left(arrow|rightarrow)|rightarrow|maps(to|from))|zenge|
      oparrow(left|right))|dot(s|p)|e(ss(sim|dot|eq(qgtr|gtr)|approx|gtr)|q(
      slant|q)?|ft(slice|harpoon(down|up)|threetimes|leftarrows|arrow(t(ail|
      riangle))?|right(squigarrow|harpoons|arrow(s|triangle|eq)?))|adsto)|
      vertneqq|floor|l(c(orner|eil)|floor|l|bracket)?|a(ngle|mbda)|rcorner|bag)
      |a(s(ymp|t)|ngle|pprox(eq)?|l(pha|eph)|rrownot|malg)|V(dash|vdash)|r(h(o|
      d)|ceil|times|i(singdotseq|ght(s(quigarrow|lice)|harpoon(down|up)|
      threetimes|left(harpoons|arrows)|arrow(t(ail|riangle))?|rightarrows))|
      floor|ange|r(ceil|parenthesis|floor|bracket)|bag)|g(n(sim|eq(q)?|approx)|
      tr(sim|dot|eq(qless|less)|less|approx)|imel|eq(slant|q)?|vertneqq|amma|g(
      g)?)|Finv|xi|m(ho|i(nuso|d)|o(o|dels)|u(ltimap)?|p|e(asuredangle|rge)|aps
      (to|from(char)?))|b(i(n(dnasrepma|ampersand)|g(s(tar|qc(up|ap))|nplus|c(
      irc|u(p|rly(vee|wedge))|ap)|triangle(down|up)|interleave|o(times|dot|plus
      )|uplus|parallel|vee|wedge|box))|o(t|wtie|x(slash|circle|times|dot|plus|
      empty|ast|minus|b(slash|ox|ar)))|u(llet|mpeq)|e(cause|t(h|ween|a))|lack(
      square|triangle(down|left|right)?|lozenge)|a(ck(s(im(eq)?|lash)|prime|
      epsilon)|r(o|wedge))|bslash)|L(sh|ong(left(arrow|rightarrow)|rightarrow|
      maps(to|from))|eft(arrow|rightarrow)|leftarrow|ambda|bag)|Arrownot)'
  tex_keyword:
    '(?:backmatter|else|fi|frontmatter|ftrue|mainmatter|if(?:case|cat|dim|eof|
      false|hbox|hmode|inner|mmode|num|odd|undefined|vbox|vmode|void|x)?)'
  unit:       '(pt|pc|in|bp|cm|mm|cc|sp|em|ex)' # valid TeX units
  uns_int:    '\d+'
  uns_real:   '(\d+\.\d*|\d*\.\d+)'
  uns_number: '({{uns_real}}|{{uns_int}})'
  number:     '[\+\-]*{{uns_number}}'
  # To be continued: this should list all (most?) of the Lua functions that
  # ConTeXt provides, so we can highlight them appropriately inside Lua code.
  lua_functions:     '(tex.s?print)|context'
  # Also needs some TLC, but eventually these variables (or ones like them)
  # should let us highlight TikZ syntax nicely. The problem is, the TikZ
  # grammar is pretty big, and I'm not well versed enough in it to know how
  # best to highlight it.
  tikz_path_op:      '(draw|fill(draw)?|path|node)'
  tikz_draw_cmd:     '(--|rectangle|node)'

# -----------------------------------------------------------------------------
# MAIN
# -----------------------------------------------------------------------------
# A note on the naming convention I've been using for contexts (we have the
# unfortunate coincidence that the term 'context' is used to refer to a 'block
# of code'/'function' in sublime-syntax files, and the syntax we wish to
# highlight goes by 'ConTeXt' - hopefully which is meant will be clear based on
# the situation at hand):
#   * if it ends in a '/' then it pops off when (and only when) it finds a
#       match (what a 'match' means will depend on the particular context, but
#       e.g. 'group/' is looking to match something like '{...}')
#   * ending in '*/' means the same as '/', except that it will pop off if it
#       can't find any match - it is optional. (I wanted to use '?' for this
#       purpose, but it is not allowed in a context name)
#   * otherwise it never pops, it just remains at the current level of scope -
#       generally these are the ones intended for 'include'-ing (which you can
#       think of as just 'copy-paste'-ing that contexts code wherever the
#       include statement occurs)
# Oh, one more note: the characters that can be used in a context name are
# quite generous - you can use more of the ASCII character set than you'd
# expect! So I've been using '.' to pretend that I have namespaces, but don't
# be fooled, there is only the global namespace (as far as I know).
contexts:
  main:
  - include: tex
  - include: lua
  - include: tikz
  - include: math
  # To be clear, this is the bit matching ConTeXt specific syntax.
  - include: context
  # The 'default' context is intended to match any leftovers that haven't been
  # caught by 'tex', 'lua', ..., or 'context'.
  - include: default

  prototype:
  - include: comments

  comments:
  # Because these matches are applied one line at a time, we can use this very
  # simple regex instead of something like '\%.*?$'.
  - match: '\%.*'
    scope: comment.tex

# -----------------------------------------------------------------------------
# TEX
# -----------------------------------------------------------------------------
  tex:
  - include: tex.keyword
  - include: tex.def

  tex.keyword:
  - match: '\\{{tex_keyword}}\b'
    scope: keyword.tex

  tex.def:
  - match: '\\[egx]?def\b'
    scope: support.function.control-word.tex
    # Things are pushed onto the stack in the order they are written, so that
    # after this 'push', 'tex.def.assignable/' will be on top of the stack,
    # with 'tex.def.parameters*/' just below it and 'tex.def.group/' below
    # that.
    push: [
      tex.def.group/,
      tex.def.parameters*/,
      tex.def.assignable/,
    ]

  tex.def.assignable/:
  # although usually you '\def' a control word, it is also possible to '\def' a
  # control symbol or an active character
  - match: '\\[a-zA-Z]+'
    scope: support.function.control-word.tex
    pop: true
  - match: '\\[^a-zA-Z]'
    scope: constant.other.control-symbol.tex
    pop: true
  - match: '[^\s]'
    scope: constant.character.active-character.tex
    pop: true

  tex.def.parameters*/:
  - match: '\#([1-9]|(?=\{))'
    scope: variable.parameter.tex-parameter.tex
  - match: '(?=\{)'
    pop: true

  # For completeness sake we have
  #   tex.def.group
  #   tex.def.group/
  #   tex.def.group*/
  #   tex.def.groups*/
  # although we only need one or two of these. It's nice and fairly easy to
  # provide them all though, so why not.
  tex.def.group:
  - match: '\{'
    push: tex.def.group.core/

  tex.def.group/:
  - match: '\{'
    set: tex.def.group.core/

  tex.def.group*/:
  - include: tex.def.group/
  - match: '(?=[^\s\{])'
    pop: true

  tex.def.groups*/:
  - include: tex.def.group
  - match: '(?=[^\s\{])'
    pop: true

  tex.def.group.core/:
  - meta_scope: def.group.tex
  - match: '\}'
    pop: true
  - match: '\#[1-9]'
    scope: variable.parameter.tex
  # We need to make sure to handle nested groups {...} ourselves before main
  # does, so that we can highlight parameters '#n'. Thus we 'include'
  # tex.def.group just before 'include'-ing main.
  - include: tex.def.group
  - include: main

# -----------------------------------------------------------------------------
# LUA
# -----------------------------------------------------------------------------
  lua:
  - include: lua.block
  - include: lua.inline

  lua.block:
  - match: '\\start(lua(code)?)\b'
    scope: entity
    push:
    # The '(\1)' references the first capture group of the match below it on
    # the stack (so in this case, it will simply refer to 'lua' or 'luacode').
    - match: '\\stop(\1)\b'
      scope: entity
      pop: true
    - include: lua.main

  lua.inline:
  - match: '\\(directlua|ctxlua)\b'
    scope: support.function
    push: lua.group/

  lua.main:
  - include: lua.group
  - include: lua.context
  # This bit is where we include the default Lua syntax highlighting that
  # Sublime Text provides.
  - include: 'Packages/Lua/Lua.sublime-syntax'

  lua.context:
  - match: '\b{{lua_functions}}\b'
    scope: support.function

  lua.group:
  - match: '\{'
    push: lua.group.core/

  lua.group/:
  - match: '\{'
    set: lua.group.core/

  lua.group*/:
  - include: lua.group/
  - match: '(?=[^\s\{])'
    pop: true

  lua.groups*/:
  - include: lua.group
  - match: '(?=[^\s\{])'
    pop: true

  lua.group.core/:
  - meta_scope: lua.group.tex
  - match: '\}'
    pop: true
  - include: lua.main

# -----------------------------------------------------------------------------
# TIKZ
# -----------------------------------------------------------------------------
# For the moment, I've commented this section out (which doesn't break the
# line '- include: tikz' inside the main context, it just silently fails). It
# could do with some work.
  # tikz:
  # - include: tikz.block
  # - include: tikz.inline

  # tikz.block:
  # - match: '\\start(tikzpicture)\b'
  #   scope: entity
  #   push: [
  #     tikz.block.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.block.main/:
  # - match: '\\stop(\1)\b'
  #   scope: entity
  #   pop: true
  # - include: tikz.core

  # tikz.inline:
  # - match: '\\tikz\b'
  #   scope: support.function
  #   push: [
  #     tikz.inline.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.inline.main/:
  # - match: '(?<=;)'
  #   pop: true
  # - include: tikz.core

  # tikz.core:
  # - include: tikz.scope
  # - include: tikz.foreach
  # - include: tikz.draw
  # - include: main

  # tikz.scope:
  # - match: '\\start(scope)\b'
  #   scope: entity
  #   push: [
  #     tikz.scope.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.scope.main/:
  # - match: '\\stop(\1)\b'
  #   scope: entity
  #   pop: true
  # - include: tikz.core

  # tikz.foreach:
  # - match: '\\foreach\b'
  #   scope: keyword
  #   push: [
  #     tikz.foreach.loop/,
  #     tikz.foreach.iterable/,
  #     tikz.foreach.variables/,
  #   ]

  # tikz.foreach.variables/:
  # - match: '\bin\b'
  #   scope: keyword
  #   pop: true
  # - match: '\\[a-zA-Z]+'
  #   scope: support.function

  # tikz.foreach.iterable/:
  # - match: '\\[a-zA-Z]+'
  #   scope: support.function
  #   pop: true
  # - match: '\{'
  #   set:
  #   - match: '\}'
  #     pop: true
  #   - match: '\.{3}'
  #   - match: '/'
  #   - include: tikz.math_expr
  #   - include: main

  # tikz.foreach.loop/:
  # - match: '\{'
  #   set:
  #   - match: '\}'
  #     pop: true
  #   - include: tikz.core
  # - match: '(?=\\{{tikz_draw_cmd}}\b)'
  #   set: tikz.inline.main/

  # tikz.draw:
  # - match: '\\{{tikz_draw_cmd}}\b'
  #   scope: support.function
  #   push: [
  #     tikz.draw.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.draw.main/:
  # - match: ';'
  #   pop: true
  # - match: '(\+{1,2})?\s*\('
  #   captures:
  #     '1': keyword
  #   push:
  #   - match: '\)'
  #     pop: true
  #   - include: tikz.math_expr
  #   - include: main
  # - match: '{{tikz_path_op}}'
  #   push: [
  #     default.group*/,
  #     tikz.lists*/,
  #   ]

  # tikz.list/:
  # - match: '\['
  #   set:
  #   - match: '\]'
  #     pop: true
  #   - match: '([a-zA-Z]+(?:[\sa-zA-Z])*)\s*([<>]?=)'
  #     captures:
  #       '1': variable.parameter
  #       '2': keyword
  #     push:
  #     - match: '(?=[,\]])'
  #       pop: true
  #     - include: tikz.math_expr
  #     - include: main
  #   - include: main

  # tikz.list*/:
  # - match: '(?=[\[])'
  #   set: tikz.list/
  # - match: '(?=[^\s\[])'
  #   pop: true

  # tikz.lists*/:
  # - match: '(?=[\[])'
  #   push: tikz.list/
  # - match: '(?=[^\s\[])'
  #   pop: true

  # tikz.math_expr:
  # - match: '[\+\-\/\*]'
  #   scope: keyword
  # - match: '{{uns_number}}'
  #   scope: constant.numeric

# -----------------------------------------------------------------------------
# MATH
# -----------------------------------------------------------------------------
  math:
  # It is important that math.display comes before math.inline, so that '$$'
  # gets interpreted as beginning TeX-style display math mode instead of
  # entering and immediately exiting TeX-style inline math mode. That said,
  # you really shouldn't be using $$...$$ (TeX-style display math) in ConTeXt.
  - include: math.displays
  - include: math.display
  - include: math.inline

  math.inline:
  - match: '\\(m|math|mathematics)\b'
    scope: support.function
    push: math.group/
  - match: '(\$)'
    scope: entity
    push:
    - match: '(\1)'
      scope: entity
      pop: true
    - include: math.main

  math.display:
  - match: '\\start(formula)\b'
    scope: entity
    push:
    - match: '\\stop(\1)\b'
      scope: entity
      pop: true
    - include: math.main
  - match: '(\$\$)'
    scope: entity
    push:
    - match: '(\1)'
      scope: entity
      pop: true
    - include: math.main

  math.displays:
  - match: '\\start(formulas)\b'
    scope: entity
    push:
    - match: '\\stop(\1)\b'
      scope: entity
      pop: true
    - include: math.display

  math.main:
  # This context is the main workhorse of math highlighting.
  - include: math.align
  - include: math.cases
  - include: math.group
  - include: math.substack
  - include: math.text
  # Sure, why not include lua.inline, it can be nice to properly highlight an
  # inline Lua call.
  - include: lua.inline
  - include: math.default

  math.default:
  - match: '{{number}}'
    scope: constant.numeric
  - include: default
    # This match is what makes plain text within math mode highlight like a
    # string
  - match: '.'
    scope: string.math.tex

  math.text:
  - match: '\\text\b'
    scope: support.function
    push: default.group/
  - match: '\\start(intertext)\b'
    scope: entity
    push:
    - match: '\\stop(\1)\b'
      scope: entity
      pop: true
    - include: main

  math.substack:
  - match: '\\start(substack)\b'
    scope: entity
    push:
    - match: '\\stop(\1)\b'
      scope: entity
      pop: true
    - match: '\\NR\b'
      scope: keyword
    - include: math.main

  math.cases:
  # This context is setup to match \startmathcases[optional square brackets,
  # pass some options] ... \stopmathcases, and between them it will match
  # rows: so highlight the first bit of a row '\NC ...' as math. The second bit
  # can be either '\NC ... \NR' or '\MC ... \NR', which will be highlighted as
  # text and math respectively (NC = new column and MC = math column).
  - match: '\\start(mathcases)\b'
    scope: entity
    push: [
      math.cases.main/,
      default.list*/,
    ]

  math.cases.main/:
  - match: '\\stop(\1)\b'
    scope: entity
    pop: true
  - match: '\\NC\b'
    scope: keyword
    push: [
      math.cases.two/,
      math.cases.one/,
    ]

  math.cases.one/:
  - match: '(?=\\[NM]C\b)'
    pop: true
  - include: math.main

  math.cases.two/:
  - match: '\\NC\b'
    scope: keyword
    set:
    - include: math.cases.two.core/
    - include: main
  - match: '\\MC\b'
    scope: keyword
    set:
    - include: math.cases.two.core/
    - include: math.main

  math.cases.two.core/:
  - match: '\\NR\b'
    scope: keyword
    pop: true

  math.align:
  - match: '\\start(align|mathalignment)\b'
    scope: entity
    push: [
      math.align.core/,
      default.list*/,
    ]

  math.align.core/:
  - match: '\\stop(\1)\b'
    scope: entity
    pop: true
  - match: '\\N[CR]\b'
    scope: keyword
  - include: math.main

  math.group:
  - match: '\{'
    push: math.group.core/

  math.group/:
  - match: '\{'
    set: math.group.core/

  math.group*/:
  - include: math.group/
  - match: '(?=[^\s\{])'
    pop: true

  math.groups*/:
  - include: math.group
  - match: '(?=[^\s\{])'
    pop: true

  math.group.core/:
  - meta_scope: math.group.tex
  - match: '\}'
    pop: true
  - include: math.main

# -----------------------------------------------------------------------------
# CONTEXT
# -----------------------------------------------------------------------------
# This section is devoted to matching syntax unique to ConTeXt
  context:
  - include: context.tables
  - include: context.itemize
  - include: context.def

  context.def:
  # Match some ConTeXt specific variations of '\def'
  - include: context.texdef
  - include: context.define

  context.texdef:
  - match: '\\start(texdefinition)\b'
    scope: entity
    push: [
      context.texdef.main/,
      context.texdef.arguments*/,
      context.texdef.name/,
      context.texdef.prefixes*/,
    ]

  context.texdef.prefixes*/:
  - match: '\b(global|(un)?expanded)\b'
    scope: constant.other
  - match: '(?=[^\s])'
    pop: true

  context.texdef.name/:
  - match: '[a-zA-Z]+'
    scope: support.function
    pop: true

  context.texdef.arguments*/:
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: variable.parameter.tex
  - match: '(?=[^\s])'
    pop: true

  context.texdef.main/:
  # Inside a 'texdefinition', ConTeXt treats comments differently - now '%%'
  # denotes a comment, and '%' is just a literal percentage sign
  - meta_include_prototype: false
  - match: '\\stop(\1)\b'
    scope: entity
    pop: true
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: variable.parameter.tex
  - include: context.texdef.comment
  - include: context.texdef.group
  - include: main

  context.texdef.comment:
  - meta_include_prototype: false
  - match: '\%\s*\%.*'
    scope: comment

  context.texdef.group:
  - meta_include_prototype: false
  - match: '\{'
    push: context.texdef.group.core/

  context.texdef.group.core/:
  - meta_include_prototype: false
  - meta_scope: def.group.tex
  - match: '\}'
    pop: true
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: variable.parameter.tex
  - include: context.texdef.comment
  # Just like with tex.def.group.core/, we have to make sure to intercept any
  # groups {...} before main gets to them, if we want to highlight parameters
  # '#n' inside nested groups
  - include: context.texdef.group
  - include: main

  context.define:
  - match: '\\define\b'
    scope: support.function
    push: [
      tex.def.group/,
      tex.def.assignable/,
      context.count.list*/,
    ]

  context.itemize:
  - match: '\\start(itemize)\b'
    scope: entity.control-word.tex
    push: [
      context.itemize.core/,
      default.lists*/,
    ]

  context.itemize.core/:
  - match: '\\stop(\1)\b'
    scope: entity.control-word.tex
    pop: true
  - match: '\\(item|head)\b'
    scope: keyword.tex
  - include: main

  context.tables:
  # ConTeXt has many ways to create tables (for historical reasons), some of
  # which are simply deprecated and others just have pros and cons. In fact
  # 'table's are deprecated, but I didn't know that before writing some (now
  # rather messy) support for them, so it's here now.
  #   Also included so far (with very very basic support) is the 'TABLE' way of
  # doings tables.
  - include: context.table
  - include: context.TABLE

  context.TABLE:
  - match: '\\bTABLE\b'
    scope: entity.control-word.tex
  - match: '\\eTABLE\b'
    scope: entity.control-word.tex
  - match: '\\[eb]T[RD]\b'
    scope: entity.control-word.tex
    push: default.lists*/

  context.table:
  - match: '\\start(table)\b'
    scope: entity.control-word.tex
    push: [
      context.table.core/,
      context.table.spec.list*/,
    ]

  context.table.core/:
  - match: '\\stop(\1)\b'
    scope: entity.control-word.tex
    pop: true
  - match: '(?=((?!\\([HV]L|NC|[FMLSNA]R)\b).)*?\\{{math_builtin}}\b)'
    push:
    - include: context.table.entry
    - include: math.main
  - match: ''
    push:
    - include: context.table.entry/
    - include: main

  context.table.entry/:
  - match: '(?=\\([HV]L|NC|[FMLSNA]R)\b)'
    pop: true
  - match: '\\([HV]L|NC|[FMLSNA]R)\b'
    scope: keyword.tex
  - match: '\\Use\b'
    scope: support.function.control-word.tex
    push: [
      context.guess.group/,
      context.table.spec.list/,
      context.count.group/,
    ]
  - match: '\\(REF|ReFormat)\b'
    scope: support.function.control-word.tex
    push: [
      context.guess.group/,
      context.table.spec.list/,
    ]

  context.count.group/:
  - match: '\{'
    set:
    - match: '\}'
      pop: true
    - match: '{{uns_int}}'
      scope: constant.numeric

  context.count.list*/:
  - match: '\['
    set:
    - match: '\]'
      pop: true
    - match: '{{uns_int}}'
      scope: constant.numeric
  - match: '(?=[^\s\[])'
    pop: true

  context.table.spec.list:
  - match: '\['
    push: context.table.spec.list.core/

  context.table.spec.list/:
  - match: '\['
    set: context.table.spec.list.core/

  context.table.spec.list*/:
  - include: context.table.spec.list/
  - match: '(?=[^\s\[])'
    pop: true

  context.table.spec.lists*/:
  - include: context.table.spec.list
  - match: '(?=[^\s\[])'
    pop: true

  context.table.spec.list.core/:
  - meta_scope: table.spec.list.tex
  - match: '\]'
    pop: true
  - include: context.table.spec
  - include: main

  # This variation of the 'group' looks inside the group (as far as it simply
  # can, which is for the rest of the line (because Sublime Text applies
  # match regexes one line at a time) or until the first '}', whichever comes
  # first) and tries to guess whether its contents are math or plain text - it
  # then applies highlighting accordingly.
  context.guess.group:
  - match: '\{'
    push: context.guess.group.core/

  context.guess.group/:
  - match: '\{'
    set: context.guess.group.core/

  context.guess.group*/:
  - include: context.guess.group/
  - match: '(?=[^\s\{])'
    pop: true

  context.guess.groups*/:
  - include: context.guess.group
  - match: '(?=[^\s\{])'
    pop: true

  context.guess.group.core/:
  - match: '(?=[^\}]*?\\{{math_builtin}}\b)'
    set:
    - meta_scope: context.guess.math.group.tex
    - match: '\}'
      pop: true
    - include: math.main
  - match: ''
    set:
    - meta_scope: context.guess.text.group.tex
    - match: '\}'
      pop: true
    - include: main

  context.table.spec:
  - match: '([lcrx])?([wp]\({{number}}\))'
    captures:
      '1': keyword
      '2': support.function
  - match: '[lcr]'
    scope: keyword
  - match: '[BISRT]'
    scope: string
  - match: '[f]'
    scope: string
    push: default.group/
  - match: '[mM]'
    scope: constant.other
  - match: '[nN]{{uns_int}}\.{{uns_int}} '
    scope: entity
  - match: '[qQ]{{uns_int}}\,{{uns_int}} '
    scope: entity
  - match: '[soijk](\{{{uns_int}}\}|\({{number}}{{unit}}\)|\d)'
    scope: variable.parameter

# -----------------------------------------------------------------------------
# DEFAULT
# -----------------------------------------------------------------------------
# This section applies matches very broadly, and only gets the chance to match
# stuff if no other match has been found.
  default:
  - include: default.if
  - include: default.group
  - include: default.start_stop
  - include: default.control_word
  - include: default.control_symbol

  default.if:
  - match: '\\if[a-zA-Z]+'
    scope: keyword
  - match: '\\(else|fi)\b'
    scope: keyword

  default.control_symbol:
  - match: '\\[^a-zA-Z]'
    scope: constant.character

  default.start_stop:
  - match: '\\(start|stop)[a-zA-Z]+'
    scope: entity
    push: default.lists*/

  default.control_word:
  - match: '\\[a-zA-Z]+'
    scope: support.function
    push: default.lists*/

  default.group:
  - match: '\{'
    push: default.group.core/

  default.group/:
  - match: '\{'
    set: default.group.core/

  default.group*/:
  - include: default.group/
  - match: '(?=[^\s\{])'
    pop: true

  default.groups*/:
  - include: default.group
  - match: '(?=[^\s\{])'
    pop: true

  default.group.core/:
  - meta_scope: default.group.tex
  - match: '\}'
    pop: true
  - include: main

  # I've taken to calling these 'lists', what they are is simply something
  # like '[...]'. That is, a square-bracket delimited thing. Inside the list,
  # we do some very simple matches, e.g. take care of key=value style syntax,
  # and finally (this bit is debatable) colour any leftover plain text as a
  # string.
  default.list:
  - match: '\['
    push: default.list.core/

  default.list/:
  - match: '\['
    set: default.list.core/

  default.list*/:
  - include: default.list/
  - match: '(?=[^\s\[])'
    pop: true

  default.lists*/:
  - include: default.list
  - match: '(?=[^\s\[])'
    pop: true

  default.list.core/:
  - meta_scope: default.list.tex
  - match: '\]'
    pop: true
  - match: '\,'
  - match: '{{number}}(\s*{{unit}})?'
    scope: constant.numeric
  - match: '([a-zA-Z]+)(=)'
    captures:
      '1': variable.parameter
      '2': keyword
  - match: ':'
    scope: variable.parameter
  - include: main
  - match: '.'
    scope: string
