%YAML 1.2
---
name: ConTeXt
file_extensions:
  - tex
  - mkii
  - mkiv
  - mkvi
  - mkix
  - mkxi
scope: text.tex.context
first_line_match: '^(%.*?macros\s*=\s*mk[vx]i|\s*\\(starttext|usemodule))\b'

contexts:
  prototype:
    - include: comment

  main:
    - include: math
    - include: Lua
    - include: MetaFun
    - include: JavaScript
    - include: XML
    - include: LMX
    - include: ConTeXt
    - include: TeX
    - include: control
    - include: generic.group

  comment:
    - include: comment.TeX

  comment.TeX:
    - include: scope:text.tex#comments

  math:
    - include: math.display
    - include: math.inline

  math.display:
    - match: '\$\$'
      scope: string.math-toggle.display.context
      push:
        - meta_content_scope: meta.environment.math.display.context
        - match: '\$\$'
          scope: string.math-toggle.display.context
          pop: true
        - include: math.main
    - match: '\\start(formula)\b'
      scope: support.function.control-word.context
      push: [
        math.display.core/,
        generic.list*/,
      ]
  math.display.core/:
    - meta_content_scope: meta.environment.math.display.context
    - include: generic.stop/
    - include: math.main

  math.inline:
    - match: '\$'
      scope: string.math-toggle.inline.context
      push:
        - meta_content_scope: meta.environment.math.inline.context
        - match: '\$'
          scope: string.math-toggle.inline.context
          pop: true
        - include: math.main
    - match: '\\(m|math|mathematics)\b'
      scope: support.function.control-word.context
      push: [
        math.group*/,
        generic.list*/,
      ]

  math.group:
    - match: '\{'
      push: math.group.core/
  math.group/:
    - match: '\{'
      set: math.group.core/
  math.group*/:
    - include: math.group/
    - include: generic.pop-if-no-group/
  math.group.core/:
    - meta_scope: meta.environment.brace.group.tex.context
    - meta_content_scope: meta.environment.math.inline.context
    - include: generic.pop-at-group-end/
    - include: math.main

  math.main:
    - include: math.constant
    - include: LMX
    - include: math.operator
    - include: math.text
    - include: math.dummy-group
    - include: Lua
    - include: TeX
    - include: math.control-sequence
    - match: '[^\s{}\[\]()]'
      scope: string.math.context

  math.control-sequence:
    - include: control.word.tab
    - include: control.word.conditional
    - match: '\\start([[:alpha:]]+)'
      scope: support.function.control-word.context
      push: generic.assignment*/
    - include: control.word.generic.no-arguments
    - include: control.symbol

  math.constant:
    - include: scope:text.tex#math-numerics

  math.operator:
    - include: scope:text.tex#math-operators

  math.dummy-group:
    - match: '\{'
      push: math.dummy-group.core/
  math.dummy-group.core/:
    - meta_scope: meta.environment.brace.group.tex.context
    - include: generic.pop-at-group-end/
    - include: math.main

  math.text:
    - match: '\\start(intertext)\b'
      scope: support.function.control-word.context
      push:
        - include: generic.stop/
        - include: main
    - match: '\\(inter)?text\b'
      scope: support.function.control-word.context
      push: generic.group*/

  Lua:
    - include: Lua.block
    - include: Lua.inline

  Lua.block:
    - match: '\\start(LUA)\b'
      scope: support.function.control-word.context
      push: [
        Lua.block.LUA/,
        generic.list-or-assignment*/,
      ]
    - match: '\\start(luacode)\b'
      scope: support.function.control-word.context
      push: Lua.block.luacode/
    - match: '\\start(lua)\b'
      scope: support.function.control-word.context
      push: Lua.block.lua/

  Lua.block.LUA/:
    - match: ''
      set: Lua.block.LUA.scope
      with_prototype:
        - match: '(?=\\stopLUA\b)'
          pop: true
        - include: Lua.block.gobble-braces
  Lua.block.LUA.scope:
    - meta_content_scope: source.lua.major
    - meta_include_prototype: false
    - match: '--(?!\[\[)'
      push:
        - meta_scope: comment.line.double-dash.lua
        - match: '$|(?=\\stopLUA\b)'
          pop: true
    - include: scope:source.lua

  Lua.block.luacode/:
    - match: ''
      set: Lua.block.luacode.scope
      with_prototype:
        - match: '(?=\\stopluacode\b)'
          pop: true
        - include: Lua.block.gobble-braces
  Lua.block.luacode.scope:
    - meta_content_scope: source.lua.major
    - meta_include_prototype: false
    - match: '--(?!\[\[)'
      push:
        - meta_scope: comment.line.double-dash.lua
        - match: '$|(?=\\stopluacode\b)'
          pop: true
    - include: scope:source.lua

  Lua.block.lua/:
    - match: ''
      set: Lua.block.lua.scope
      with_prototype:
        - match: '(?=\\stoplua\b)'
          pop: true
        - include: Lua.block.gobble-braces
  Lua.block.lua.scope:
    - meta_content_scope: source.lua.minor
    - match: '--(?!\[\[)'
      push:
        - meta_scope: comment.line.double-dash.lua
        - match: '(?=\\stoplua\b)'
          pop: true
    - include: scope:source.lua

  Lua.block.gobble-braces:
    - match: '[{}]'

  Lua.inline:
    - match: '\\(cldcontext|(ctx|direct)lua)\b'
      scope: support.function.control-word.context
      push: Lua.inline.group*/

  Lua.inline.group/:
    - match: '\{'
      scope: meta.environment.brace.group.tex.context
      set: Lua.inline.group.core/
  Lua.inline.group*/:
    - include: Lua.inline.group/
    - include: generic.pop-if-no-group/
  Lua.inline.group.core/:
    - match: ''
      set: Lua.inline.lua.scope
      with_prototype:
        - include: generic.pop-at-group-end/
        - include: Lua.inline.comment
        - include: Lua.inline.deep-group
        - include: TeX.parameter
        - include: comment.TeX
        - include: control.word.generic.no-arguments
        - include: control.symbol
  Lua.inline.lua.scope:
    - meta_content_scope: source.lua.minor meta.environment.brace.group.tex.context
    - include: scope:source.lua

  Lua.inline.deep-group:
    - match: '\{'
      scope: meta.environment.table.lua
      push: Lua.inline.deep-group.core/
  Lua.inline.deep-group.core/:
    - match: ''
      set: Lua.inline.deep-lua.scope
      with_prototype:
        - include: generic.pop-at-group-end/
        - include: Lua.inline.comment
        - include: Lua.inline.deep-group
        - include: TeX.parameter
        - include: comment.TeX
        - include: control.word.generic.no-arguments
        - include: control.symbol
  Lua.inline.deep-lua.scope:
    - meta_content_scope: meta.environment.table.lua
    - include: scope:source.lua

  Lua.inline.comment:
    - match: '--(?!\[\[)'
      push:
        - meta_scope: comment.line.double-dash.lua
        - match: '(?=\})'
          pop: true
        - match: '\\.'
        - match: '\{'
          push:
            - match: '\\.'
            - match: '\}'
              pop: true

  MetaFun:
    - include: MetaFun.block

  MetaFun.block:
    - match: '\\start(MPinitializations)\b'
      scope: support.function.control-word.context
      push: MetaFun.block.core/
    - match: '\\start(MPinclusions)\b'
      scope: support.function.control-word.context
      push: [
        MetaFun.block.core/,
        generic.group*/,
        generic.list*/,
      ]
    - match: '\\start(MP(drawing|environment|page)?)\b'
      scope: support.function.control-word.context
      push: [
        MetaFun.block.core/,
        generic.list-or-assignment*/,
      ]
    - match: '\\start(MP(extensions|run|code|definitions|clip|positionmethod)|staticMPfigure)\b'
      scope: support.function.control-word.context
      push: [
        MetaFun.block.core/,
        generic.group*/,
      ]
    - match: '\\start((MPposition|(static|use|(re)?usable|unique)MP|uniqueMPpage)graphic)\b'
      scope: support.function.control-word.context
      push: [
        MetaFun.block.core/,
        generic.group*/,
        generic.group*/,
      ]

  MetaFun.block.core/:
    - meta_include_prototype: false
    - meta_content_scope: source.metapost.metafun
    - include: generic.stop/
    - include: MetaFun.main

  MetaFun.main:
    - include: scope:source.metapost#types
    - include: scope:source.metapost#definitions
    - include: scope:source.metapost#loops
    - include: scope:source.metapost#comment
    - include: MetaFun.constants
    - include: MetaFun.variables
    - include: MetaFun.labels
    - include: LMX
    - include: MetaFun.operators
    - include: MetaFun.functions
    - include: MetaFun.environments
    - include: MetaFun.TeX
    - include: MetaFun.ConTeXt

  MetaFun.constants:
    - match: '\b(Page(Offset|Depth|StateAvailable)?|(Top|Bottom|Back|Cut)Space|(Left|Right|Inner|Outer)(Edge|Margin)(Width|Distance)|(Top|Header|Footer|Bottom)(Height|Distance)|(Makeup|Text)(Height|Width)|(Print)?Paper(Height|Width)|LayoutColumn(s|Distance|Width)|(Top|BaseLine)Skip|([HV]|BodyFont)Size|EmWidth|ExHeight|Field|LineHeight|On(Right|Odd)Page|InPageBody|(Real|Last)?PageNumber|NOf(Pages|Columns)|Current(Column|Layout|Width|Height)|Overlay(Box|Offset|Color|Depth|Height|Line(Color|Width)|Width)|Strut(Depth|Height)|shadedup|fullsquare|(full|unit)diamond|[ul][lr]triangle|(unit|[btrl]|[ul][lr])circle|yellow)\b'
      scope: constant.other.metapost.metafun
    - include: scope:source.metapost#constants

  MetaFun.variables:
    - match: '\b(ah(variant|dimple))\b'
      scope: variable.parameter.internal.metapost.metafun
    - include: scope:source.metapost#variables

  MetaFun.labels:
    - match: '\b((the)?textext|(thefree|free(dot)?)label)(\.(top|[ul]?(lft|rt)|bot|origin|raw))?\b'
      scope: support.function.label.metapost.metafun
    - match: '\b(thelabel|(dot)?labels?)\.(origin|raw)\b'
      scope: support.function.label.metapost.metafun
    - include: scope:source.metapost#labels

  MetaFun.operators:
    - match: '\b(along|(bottom|left|[ul][rl]|right|top)?enlarged|blownup|cornered|crossed|curved|laddered|paralleled|punked|random(ized|shifted)|shadedinto|shortened|smoothed|softened|stretched|squeezed|superellipsed|[ul][rl]moved|uncolored|with(shade(method|direction)?|fillcolor|transparency)|[xy]shifted|([xy]|xy)sized|xyscaled)\b'
      scope: keyword.operator.metapost.metafun
    - match: '-{3}'
      scope: keyword.path-operator.metapost.metafun
    - include: scope:source.metapost#operators

  MetaFun.functions:
    - match: '\b(addbackground|(cos|sin|cot|tan)|a(cos|sin|tan)|a?(cos|sin)h|(cot|tan)d|inv(cos|sin)|anglebetween|bb(width|height)|(bottom|top)boundary|boundingbox|cmyk|condition|(circular|linear)_shade|d{2,3}ecimal|externalfigure|exp|graphictext|grayed|(inner|outer)boundingbox|inv(erted)?|(left|right|center|point)arrow|(left|right)boundary|loadfigure|ln|log|paired|re((map(ped)?)?color|setcolormap|draw|fill)|register|roundedsquare|simplified|sqr|tensecircle|transparent|tripled|unspiked)\b'
      scope: support.function.metapost.metafun
    - include: scope:source.metapost#functions

  MetaFun.environments:
    - match: '\b(Start|Stop)Page\b'
      scope: support.class.metapost
    - include: scope:source.metapost#environments

  MetaFun.TeX:
    - match: '\b(b|verbatim)(tex)\b'
      scope: support.class.metapost.metafun
      push:
        - meta_content_scope: text.tex.context
        - match: '\be\2\b'
          scope: support.class.metapost.metafun
          pop: true
        - include: main

  MetaFun.ConTeXt:
    - match: '\\(MP(betex|text|pos|anchor|var|color(only)?|options|transparency|string)|includeMPgraphic)\b'
      scope: support.function.control-word.context
      push: generic.group*/
    - include: control.word.generic.no-arguments
    - include: control.symbol

  JavaScript:
    - include: JavaScript.block

  JavaScript.block:
    - match: '\\start(JSpreamble)\b'
      scope: support.function.control-word.context
      push: [
        JavaScript.block.preamble.core/,
        JavaScript.name-used-when*/,
      ]
    - match: '\\start(JScode)\b'
      scope: support.function.control-word.context
      push: [
        JavaScript.block.code.core/,
        JavaScript.name-uses-name*/,
      ]

  JavaScript.block.preamble.core/:
    - match: ''
      set: JavaScript.block.scope
      with_prototype:
        - match: '(?=\\stopJSpreamble\b)'
          pop: true
        - include: comment.TeX
        - include: control.word.generic.no-arguments
        - include: control.symbol
        - include: LMX

  JavaScript.block.code.core/:
    - match: ''
      set: JavaScript.block.scope
      with_prototype:
        - match: '(?=\\stopJScode\b)'
          pop: true
        - include: comment.TeX
        - include: control.word.generic.no-arguments
        - include: control.symbol
        - include: LMX

  JavaScript.block.scope:
    - meta_content_scope: source.js
    - match: '//.*$'
      scope: comment.line.double-slash.js
    - include: scope:source.js

  JavaScript.name-used-when*/:
    - match: '\s*(\S+)\s+(used)\s+(now|later)\b'
      captures:
        '1': entity.name.context
        '2': markup.raw.context
        '3': constant.other.context
      pop: true
    - match: ''
      pop: true

  JavaScript.name-uses-name*/:
    - match: '\s*(\S+)\s+(uses)\s+(\S+)'
      captures:
        '1': entity.name.context
        '2': markup.raw.context
        '3': entity.name.context
      pop: true
    - match: ''
      pop: true

  XML:
    - include: XML.block

  XML.block:
    - match: '\\start(XML)\b'
      scope: support.function.control-word.context
      push: [
        XML.block.core/,
        generic.list-or-assignment*/,
      ]

  XML.block.core/:
    - match: ''
      set: scope:text.xml
      with_prototype:
        - match: '(?=\\stopXML\b)'
          pop: true

  LMX:
    - include: LMX.snippets

  LMX.snippets:
    - match: '(<\?)(lua)\b'
      captures:
        '1': entity.tag.begin.context
        '2': entity.tag.lua.context
      push: LMX.lua.scope
      with_prototype:
        - match: '(\?>)'
          captures:
            '1': entity.tag.end.context
          pop: true
        - include: LMX.inline.comment
        - include: LMX.functions

  LMX.lua.scope:
    - meta_include_prototype: false
    - meta_scope: source.lua
    - include: scope:source.lua

  LMX.inline.comment:
    - match: '--(?!\[\[)'
      push:
        - meta_scope: comment.line.double-dash.lua
        - match: '(?=\?>)'
          pop: true

  LMX.functions:
    - match: '\b(inject)\b'
      scope: support.function.lua

  ConTeXt:
    - include: ConTeXt.hiding
    - include: ConTeXt.verbatim
    - include: ConTeXt.sections
    - include: ConTeXt.macros

  ConTeXt.hiding:
    - match: '\\start(hiding)\b'
      scope: support.function.control-word.context
      push:
        - meta_scope: comment.block.context
        - include: generic.stop/


  ConTeXt.sections:
    - match: '\\(part|chapter|title|(sub){0,4}(section|subject))\b'
      scope: support.function.control-word.context
      push: [
        generic.group.name*/,
        generic.list*/,
      ]

  ConTeXt.verbatim:
    - include: ConTeXt.verbatim.inline
    - include: ConTeXt.verbatim.block

  ConTeXt.verbatim.inline:
    - match: '\\type\b'
      scope: support.function.control-word.context
      push: [
        ConTeXt.verbatim.angles_or_group*/,
        generic.assignment*/,
      ]
  ConTeXt.verbatim.angles_or_group*/:
    - match: '\{'
      scope: meta.environment.brace.group.tex.context
      set:
        - meta_include_prototype: false
        - meta_content_scope: meta.environment.brace.group.tex.context markup.raw.context
        - match: '\}'
          scope: meta.environment.brace.group.tex.context
          pop: true
        - include: ConTeXt.verbatim.dummy-group
    - match: '<<'
      set:
        - meta_include_prototype: false
        - meta_content_scope: markup.raw.context
        - match: '>>'
          pop: true
        - include: ConTeXt.verbatim.dummy-angles
    - match: '(?=[^\s\{<])'
      pop: true

  ConTeXt.verbatim.dummy-group:
    - match: '\{'
      push:
        - meta_include_prototype: false
        - include: generic.pop-at-group-end/
        - include: ConTeXt.verbatim.dummy-group
  ConTeXt.verbatim.dummy-angles:
    - match: '<<'
      push:
        - meta_include_prototype: false
        - match: '>>'
          pop: true
        - include: ConTeXt.verbatim.dummy-angles

  ConTeXt.verbatim.block:
    - match: '\\start(typing)\b'
      scope: support.function.control-word.context
      push: [
        ConTeXt.verbatim.block.core/,
        ConTeXt.verbatim.list-or-assignment*/,
      ]
    - match: '\\start(buffer)\b'
      scope: support.function.control-word.context
      push: [
        ConTeXt.verbatim.block.core/,
        ConTeXt.verbatim.list*/,
      ]
  ConTeXt.verbatim.block.core/:
    - meta_include_prototype: false
    - meta_content_scope: markup.raw.context
    - include: generic.stop/

  ConTeXt.verbatim.list-or-assignment*/:
    - meta_include_prototype: false
    - include: generic.list-or-assignment*/
  ConTeXt.verbatim.list*/:
    - meta_include_prototype: false
    - include: generic.list*/

  ConTeXt.macros:
    - include: ConTeXt.define
    - include: ConTeXt.texdef

  ConTeXt.define:
    - match: '\\define\b'
      scope: support.function.control-word.context
      push: [
        TeX.def.control-sequence*/,
        generic.list.num*/,
      ]

  ConTeXt.texdef:
    - match: '\\start(texdefinition)\b'
      scope: support.function.control-word.context
      push: [
        ConTeXt.texdef.main/,
        ConTeXt.texdef.arguments*/,
        ConTeXt.texdef.name/,
        ConTeXt.texdef.prefixes*/,
      ]

  ConTeXt.texdef.prefixes*/:
    - match: '\b((no)?spaces|global|(un)?expanded)\b'
      scope: constant.other.context
    - match: '(?=[^\s])'
      pop: true

  ConTeXt.texdef.name/:
    - match: '\S+'
      scope: entity.control-word.tex.context
      pop: true

  ConTeXt.texdef.arguments*/:
    - include: TeX.parameter
    - match: '(?=[^\s])'
      pop: true

  ConTeXt.texdef.main/:
    - meta_content_scope: meta.environment.def.context
    - include: generic.stop/
    - include: main

  TeX:
    - include: TeX.parameter
    - include: TeX.let-or-def

  TeX.parameter:
    - match: '(\#|\#{2}|\#{4}|\#{8}|\#{16}|\#{32}|\#{64})[[:digit:]]'
      scope: variable.parameter.tex.context
    - match: '(\#|\#{2}|\#{4}|\#{8}|\#{16}|\#{32}|\#{64})([[:alpha:]]+|\{.*?\})'
      scope: variable.parameter.tex.context

  TeX.let-or-def:
    - match: '\\([egx]?def|let)\b'
      scope: support.function.control-word.context
      push: TeX.def.control-sequence*/

  TeX.def.control-sequence*/:
    - match: '\\[[:alpha:]]+'
      scope: entity.control-word.tex.context
      pop: true
    - match: '\\[^[:alpha:]]'
      scope: entity.control-symbol.tex.context
      pop: true
    - match: '(?=[^\s\\])'
      pop: true

  control:
    - include: control.word
    - include: control.symbol
    - include: control.active-character

  control.word:
    - include: control.word.font
    - include: control.word.tab
    - include: control.word.conditional
    - include: control.word.generic

  control.word.tab:
    - match: '\\(NB|[BCHNR]C|ND|NG|[BCFHLMTV]L|CM|NN|[EHR]Q|[ACFHLMNS]R)\b'
      scope: keyword.control-word.tab.context
      push: generic.lists*/

  control.word.conditional:
    - match: '\\(doif[[:alpha:]]*else|(if|[[:alpha:]]*doif(else)?)[[:alpha:]]*|[[:alpha:]]+(true|false)|or|else|fi)\b'
      scope: keyword.control-word.context

  control.word.generic:
    - match: '\\[[:alpha:]]+'
      scope: support.function.control-word.context
      push: generic.lists-or-assignments*/

  control.word.generic.no-arguments:
    - match: '\\[[:alpha:]]+'
      scope: support.function.control-word.context

  control.symbol:
    - match: '\\[^[:alpha:]]'
      scope: constant.other.control-symbol.context

  control.active-character:
    - match: '[|~]'
      scope: constant.other.active-character.context

  generic.stop/:
    - match: '(?=\\stop\1\b)'
      scope: support.function.control-word.context
      pop: true

  generic.pop-if-no-group/:
    - match: '(?=[^\s\{])'
      pop: true
  generic.pop-if-no-list/:
    - match: '(?=[^\s\[])'
      pop: true

  generic.pop-at-group-end/:
    - match: '\}'
      pop: true
  generic.pop-at-list-end/:
    - match: '\]'
      pop: true

  generic.group:
    - match: '\{'
      push: generic.group.core/
  generic.group/:
    - match: '\{'
      set: generic.group.core/
  generic.group*/:
    - include: generic.group/
    - include: generic.pop-if-no-group/
  generic.groups*/:
    - include: generic.group
    - include: generic.pop-if-no-group/
  generic.group.core/:
    - meta_scope: meta.environment.brace.group.tex.context
    - include: generic.pop-at-group-end/
    - include: main

  generic.group.list*/:
    - match: '\{'
      set: generic.group.list.core/
    - include: generic.pop-if-no-group/
  generic.group.list.core/:
    - meta_scope: meta.environment.brace.group.tex.context
    - include: generic.group.core/

  generic.group.name/:
    - match: '\{'
      set: generic.group.name.core/
  generic.group.name*/:
    - include: generic.group.name/
    - include: generic.pop-if-no-group/
  generic.group.name.core/:
    - meta_scope: meta.environment.brace.group.tex.context
    - include: generic.group.core/

  generic.list:
    - match: '\['
      push: generic.list.core/
  generic.list/:
    - match: '\['
      set: generic.list.core/
  generic.list*/:
    - include: generic.list/
    - include: generic.pop-if-no-list/
  generic.lists*/:
    - include: generic.list
    - include: generic.pop-if-no-list/
  generic.list.core/:
    - meta_scope: meta.environment.list.context
    - include: generic.pop-at-list-end/
    - include: main

  generic.assignment:
    - match: '\['
      push: generic.assignment.core/
  generic.assignment/:
    - match: '\['
      set: generic.assignment.core/
  generic.assignment*/:
    - include: generic.assignment/
    - include: generic.pop-if-no-list/
  generic.assignments*/:
    - include: generic.assignment
    - include: generic.pop-if-no-list/
  generic.assignment.core/:
    - meta_scope: meta.environment.list.context
    - include: generic.list.core/
    - include: generic.key-equals

  generic.list-or-assignment:
    - match: '\['
      push: generic.list-or-assignment.core/
  generic.list-or-assignment/:
    - match: '\['
      set: generic.list-or-assignment.core/
  generic.list-or-assignment*/:
    - include: generic.list-or-assignment/
    - include: generic.pop-if-no-list/
  generic.lists-or-assignments*/:
    - include: generic.list-or-assignment
    - include: generic.pop-if-no-list/
  generic.list-or-assignment.core/:
    - meta_scope: meta.environment.list.context
    - include: generic.assignment.core/

  generic.list.num/:
    - match: '\['
      set: generic.list.num.core/
  generic.list.num*/:
    - include: generic.list.num/
    - include: generic.pop-if-no-list/
  generic.list.num.core/:
    - meta_scope: meta.environment.list.context
    - include: generic.list.core/
    - include: generic.number

  generic.number:
    - match: '[[:digit:]]+'
      scope: constant.numeric.context
  generic.key-equals:
    - match: '([[:word:].:-]+)(=)'
      captures:
        '1': variable.parameter.key.context
        '2': keyword.operator.equals.context
