%YAML 1.2
---
name: ConTeXt
file_extensions:
  - tex
  - mkii
  - mkiv
  - mkvi
  - mkix
  - mkxi
scope: text.tex.context
first_line_match: '^\s*(%.*?macros\s*=\s*mk([vx]i)|\\(start(text|document)|usemodule|setup[[:alpha:]]+))\b'
variables:
  key: '[[:alpha:][:digit:].\-\+_:;!\?<>&/]'
  setup: '{{key}}'
  verbatim: '[^%$^_#,~|\[\]\{\}<>\\[:alpha:]]'
  variable: '[[:alpha:]]'

contexts:
  prototype:
    - include: comment
    - include: template


  main:
    - include: math
    - include: Lua
    - include: MetaFun
  # - include: JavaScript
    - include: markup
    - include: table
    - include: verbatim
  # - include: catcode
    - include: heading
    - include: file
    - include: process
    - include: definition
    - include: low-level
    - include: control
    - include: scoping

  main.pop-if-stop-match-two/:
    - include: generic.pop-if-stop-match-two/
    - include: main
  main.cases/:
    - include: math.cases.pop-if-newrow/
    - include: math.cases.pop-at-end/
    - include: main


  comment:
    - include: comment.TeX
  comment.TeX:
    - match: '(%).*$\n?'
      captures:
        0: comment.line.percentage.context
        1: punctuation.definition.comment.context


  #D In \ConTeXt\ there is some preprocessing available. One aspect of this is
  #D allowing named parameters \type{#argument} in the source code, instead of
  #D the usual \TeX\ syntax \type{#1}.
  #D \startfootnote
  #D   To activate this feature, you can add a line with the directive
  #D   \type{macros=mkvi} or \type{macros=mkxi} at the top of your source file,
  #D   or change the file extension to \type{mkvi} resp.\ \type{mkxi}. Then
  #D   named arguments will be automatically translated into the usual \TeX\
  #D   style before \TeX\ gets to see them.
  #D \stopfootnote \space
  #D Another aspect is presented here: using an XML||like syntax, you can run
  #D snippets of \Lua\ \emph{before} the main \ConTeXt\ run.
  template:
    - match: '(<\?)(lua)\b'
      captures:
        1: punctuation.definition.tag.begin.context
        2: entity.name.tag.lua.context
      push:
        - meta_include_prototype: false
        - meta_scope: meta.tag.context  # meta.preprocessor.lua.context
        - meta_content_scope: source.lua.embedded.context
        - match: '\?>'
          scope: punctuation.definition.tag.end.context
          pop: true
        - include: template.Lua.functions
        - include: scope:source.lua

  #D See the comments on \type{Lua.functions}
  template.Lua.functions:
    - match: '\b(inject)\b'
      scope: support.function.library.lua


  math:
    - include: math.display
    - include: math.inline
  math.display:
    - include: math.display.double-dollar
    - include: math.display.control
  math.inline:
    - include: math.inline.dollar
    - include: math.inline.control

  math.display.control:
    - match: '(\\)startformula\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        math.main.pop-if-stopformula/,
        argument.list*/,
      ]
    - match: '(\\)start(display|d)math\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: math.main.pop-if-stop-match-two/
    - match: '(\\)display(math|mathematics)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.math*/
  math.inline.control:
    - match: '(\\)(m|math|mathematics|formula)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group.math.outer*/,
        argument.list*/,
      ]
    - match: '(\\)inline(math|mathematics)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.math.outer*/
    - match: '(\\)start(imath|mathmode)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: math.main.pop-if-stop-match-two/

  #D It is advised to not use double dollar style display math \type{$$ ... $$}
  #D directly in \ConTeXt; better is \type{\startformula ... \stopformula}.
  #D (For one, this way \ConTeXt\ has a say in keeping the vertical spacing
  #D nice.) But it can be done, so here it is. (On the other hand, single
  #D dollar style inline math \type{$ ... $} is fine.)
  math.display.double-dollar:
    - match: '\$\$'
      scope: punctuation.section.double-dollar.begin.context string.quoted.other.double-dollar.context  # meta.structure.start.context
      push: math.main.double-dollar/
  math.inline.dollar:
    - match: '\$'
      scope: punctuation.section.dollar.begin.context string.quoted.other.dollar.context
      push: math.main.dollar/

  math.main:
    - include: math.number
    - include: math.operator
    - include: math.variable
    - include: math.control
    - include: definition.parameter
    - include: scoping.math

  math.main.dollar/:
    - meta_content_scope: meta.dollar.context meta.environment.math.context
    - match: '\$'
      scope: punctuation.section.dollar.end.context string.quoted.other.dollar.context
      pop: true
    - include: math.main
  math.main.double-dollar/:
    - meta_content_scope: meta.double-dollar.context meta.environment.math.context
    - match: '\$\$'
      scope: punctuation.section.double-dollar.end.context string.quoted.other.double-dollar.context  # meta.structure.stop.context
      pop: true
    - include: math.main
  math.main.pop-if-stopformula/:
    - match: ''
      set: math.main.pop-if-stopformula.aux/
  math.main.pop-if-stopformula.aux/:
    - meta_content_scope: meta.environment.math.context
    - match: '(?=\\stopformula\b)'
      pop: true
    - include: math.main
  math.main.pop-if-stop-match-two/:
    - meta_content_scope: meta.environment.math.context
    - include: generic.pop-if-stop-match-two/
    - include: math.main
  math.main.cases/:
    - include: math.cases.pop-at-end/
    - include: math.cases.rows
    - include: math.main

  #D Should we try to handle unicode entities? Should one write math in
  #D unicode? It's nice for some things (such as writing \type{Î±} instead of
  #D the more verbose \type{\alpha}), but you can lose semantic information
  #D as well as the ability to easily tweak e.g.\ the spacing of \type{\int}
  #D throughout the whole document. Hmm.
  math.number:
    - include: generic.real
  # - match: '(\\)infty\b'
  #   captures:
  #     0: constant.other.math.context meta.control-word.context
  #     1: punctuation.definition.backslash.context

  #D We can make these lists more complete as time goes on.
  math.operator:
    - match: '([\+\-/\^_=<>])'
      scope: keyword.operator.context
    - match: '(\\)([lg]eq?|ll|gg)\b'
      captures:
        0: meta.control-word.context keyword.operator.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context

  math.variable:
    - match: '{{variable}}+'
      scope: variable.other.context

  #D In math mode, control sequences with arguments are tricky. Consider the
  #D following example.
  #D
  #D \startbuffer
  #D \startformula
  #D   \startalign
  #D     \NC \sqrt[3]{2} \NC > 2                        \NR
  #D     \NC [y]         \NC = \{ x \in X : x \sim y \} \NR
  #D   \stopalign
  #D \stopformula
  #D \stopbuffer
  #D
  #D \typebuffer
  #D
  #D This produces the output:
  #D
  #D \getbuffer
  #D
  #D On the one hand we have \type<<\sqrt[3]{2}>>, where the square brackets
  #D denote an optional argument. On the other we have \type<<\NC [y]>>, where
  #D the square brackets are part of the mathematical notation, and have
  #D nothing whatsoever to do with the control sequence \type<<\NC>>.
  #D
  #D If we use the same approach as in text mode, we will (wrongly) interpret
  #D the \type<<[y]>> as an optional argument to \type<<\NC>>. To address these
  #D kinds of problems, we implement a simple rule: \emph{no spaces allowed}
  #D between a control sequence and its arguments in math mode.
  #D
  #D One other thing, let's forget about active characters in math mode.
  math.control:
    - include: Lua
    - include: math.control.cases
    - include: math.control.intertext
    - include: math.control.sqrt
    - include: control.word.math.adjacent
    - include: control.symbol

  math.control.sqrt:
    - match: '(\\)sqrt\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group.math.adjacent*/,
        argument.list.math.adjacent*/,
      ]

  math.control.intertext:
    - match: '(\\)start(intertext)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: main.pop-if-stop-match-two/
    - match: '(\\)(inter)?text\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.adjacent*/

  #D Understanding math vs.\ text in \type{\startcases ... \stopcases} is a
  #D nice feature to have. As the code is fairly clean so far, let's keep it.
  math.control.cases:
    - match: '(\\)startcases\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        math.main.cases/,
        argument.list.adjacent*/,
      ]

  math.cases.rows:
    - match: '(\\)NC\b'
      captures:
        0: meta.control-word.context keyword.operator.alignment.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context
      push:
        - match: '(\\)NC\b'
          captures:
            0: meta.control-word.context keyword.operator.alignment.context
            1: punctuation.definition.backslash.context punctuation.definition.keyword.context
          set: main.cases/
        - match: '(\\)MC\b'
          captures:
            0: meta.control-word.context keyword.operator.alignment.context
            1: punctuation.definition.backslash.context punctuation.definition.keyword.context
          set: math.main.cases/
        - include: math.main.cases/

  math.cases.pop-at-end/:
    - match: '(?=\\stopcases\b)'
      pop: true
  math.cases.pop-if-newrow/:
    - match: '(\\)NR\b'
      captures:
        0: meta.control-word.context keyword.operator.alignment.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context
      set: argument.list.adjacent*/


  #D We try to keep track of catcode regimes in embedded \Lua. Of course, there
  #D is only so much we can do without implementing \TeX\ within Sublime Text,
  #D but for typical use cases we can do very well.
  #D
  #D What about the other namespaces \periods\ what is the situation with
  #D \type{\usercode{...}} and \type{\startusercode ... \stopusercode}.
  Lua:
    - include: Lua.block
    - include: Lua.inline

  Lua.block:
    - match: '(\\)start(luacode)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - meta_include_prototype: false
        - meta_content_scope: meta.environment.lua.major.context source.lua.embedded.context
        - include: Lua.main.pop-if-stop-match-two/
    - match: '(\\)start(lua)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - meta_content_scope: meta.environment.lua.minor.context source.lua.embedded.context
        - include: Lua.main.pop-if-stop-match-two/
  Lua.inline:
    - match: '(\\)(late|direct)lua\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group.Lua*/,
        argument.integer*/,
      ]
    #D Hmm, a bit overkill? Should some of these permit an integer as well?
    - match: '(\\)(luacode|(late|direct)lua(code)?|cld(command|context|loadfile|processfile)|ctx(command|directcommand|directlua|latecommand|latelua|lua|report|sprint|write))\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.Lua*/

  Lua.main:
    - include: Lua.control
    - include: Lua.comment.embed-friendly
    - include: Lua.functions
    - include: scope:source.lua
  Lua.main.pop-if-stop-match-two/:
    - include: generic.pop-if-stop-match-two/
    - include: Lua.main

  Lua.control:
    #D I suppose you can do \Lua\ nested inside \Lua\ if you really want
    #D \periods.
    - include: Lua
    - include: control.word.without-alignment
    - include: control.symbol

  #D Functions that \ConTeXt\ adds at the \Lua\ end. Well, there are a huge
  #D amount, but we can at least add some common ones.
  #D
  #D The \Lua\ \type{sublime.syntax} file that comes out of the box with
  #D Sublime Text uses the pattern
  #D % How can we nicely escape this string in \TeX? This ugly approach does
  #D % the job.
  #D \startluacode
  #D   context.start()
  #D   context.tt()
  #D   context.pushcatcodes("verbatim")
  #D   context(
  #D     [===[(?<![^.]\string\.|:)\b(...)\b]===] ..
  #D     [===[(?=[(\string \letterleftbrace"''\[])]===]
  #D   )
  #D   context.popcatcodes()
  #D   context.stop()
  #D \stopluacode
  #D to match library functions, where the dots \type{...} are a place||holder
  #D to be filled in with your function names. This approach has some flaws,
  #D for example it fails to handle the perfectly reasonable code:
  #D
  #D \starttyping
  #D   local cos, sin = math.cos, math.sin
  #D \stoptyping
  #D
  #D What to do. Well, let's just use a naive approach for the time being.
  Lua.functions:
    - match: '\b(context\.delayed\.[[:alpha:]]+|context\.[[:alpha:]]+|context)\b'
      scope: support.function.library.lua

  Lua.comment.embed-friendly:
    - match: '--(?!\[\[)'
      scope: punctuation.definition.comment.lua
      push:
        - meta_scope: comment.line.double-dash.lua
        - match: '$\n?'
          pop: true


  MetaFun:
    - include: MetaFun.block
    - include: MetaFun.use

  MetaFun.use:
    - match: '(\\)(MPposition|reusableMP|(re)?useMP|uniqueMP(page)?)graphic\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group.with-assignments*/,
        argument.group*/,
      ]
    - match: '(\\)setMPpositiongraphic\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group.with-assignments*/,
        argument.group*/,
        argument.group*/,
      ]
    - match: '(\\)setMPpositiongraphicrange\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group.with-assignments*/,
        argument.group*/,
        argument.group*/,
        argument.group*/,
      ]

  MetaFun.block:
    - match: '(\\)startuniqueMPgraphic\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.uniqueMPgraphic/,
        argument.group*/,
        argument.group*/,
      ]
    - match: '(\\)startuniqueMPpagegraphic\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.uniqueMPpagegraphic/,
        argument.group*/,
        argument.group*/,
      ]
    - match: '(\\)startuseMPgraphic\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.useMPgraphic/,
        argument.group*/,
        argument.group*/,
      ]
    - match: '(\\)startusableMPgraphic\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.usableMPgraphic/,
        argument.group*/,
        argument.group*/,
      ]
    - match: '(\\)startreusableMPgraphic\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.reusableMPgraphic/,
        argument.group*/,
        argument.group*/,
      ]
    - match: '(\\)startstaticMPfigure\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.staticMPfigure/,
        argument.group*/,
      ]
    - match: '(\\)startMPcode\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.MPcode/,
        argument.group*/,
      ]
    - match: '(\\)startMPdefinitions\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.MPdefinitions/,
        argument.group*/,
      ]
    - match: '(\\)startMPinclusions\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.MPinclusions/,
        argument.group*/,
        argument.list*/,
      ]
    - match: '(\\)startMPpage\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.MPpage/,
        argument.list*/,
      ]
    - match: '(\\)startMPextensions\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.MPextensions/,
        argument.group*/,
      ]
    - match: '(\\)startMPpositiongraphic\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        MetaFun.main.MPpositiongraphic/,
        argument.group*/,
        argument.group*/,
      ]

  #D The redundant code that follows is ugly, but the best approach I've found
  #D so far.
  MetaFun.main:
    - include: MetaFun.TeX
    - include: MetaFun.control
    - include: scope:source.metapost.metafun
  MetaFun.main.MPcode/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopMPcode\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.MPpage/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopMPpage\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.uniqueMPgraphic/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopuniqueMPgraphic\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.uniqueMPpagegraphic/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopuniqueMPpagegraphic\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.useMPgraphic/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopuseMPgraphic\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.usableMPgraphic/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopusableMPgraphic\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.reusableMPgraphic/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopreusableMPgraphic\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.staticMPfigure/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopstaticMPfigure\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.MPdefinitions/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopMPdefinitions\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.MPinclusions/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopMPinclusions\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.MPextensions/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopMPextensions\b)'
          pop: true
        - include: MetaFun.main
  MetaFun.main.MPpositiongraphic/:
    - match: ''
      set:
        - meta_content_scope: source.metapost.metafun.embedded.context
        - match: '(?=\\stopMPpositiongraphic\b)'
          pop: true
        - include: MetaFun.main

  MetaFun.control:
    - include: Lua
    - include: control.symbol
    - include: control.word.generic
  MetaFun.TeX:
    - match: '\b(b|verbatim)tex\b'
      scope: support.function.metapost
      push:
        - meta_content_scope: text.tex.context.embedded.metafun
        - match: '(?=\betex\b)'
          pop: true
        - include: main


  #D It would be nice for commands like \type{\em} to stand out from the crowd.
  #D On the other hand, what scope can we logically apply to them besides the
  #D usual \type{support.function}? I suppose the scopes (such as
  #D \type{markup.italic}) will have to suffice.
  markup:
    - include: markup.font
    - include: markup.quote

  markup.quote:
    - include: markup.quote.inline
    - include: markup.quote.block

  markup.quote.inline:
    - match: '(\\)(quote|blockquote|quotation|aside|speech)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group.quote*/,
        argument.list*/,
      ]

  markup.quote.block:
    - match: '(\\)startquote\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        markup.main.quote/,
        argument.list*/,
        argument.list*/,
      ]
    - match: '(\\)startblockquote\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        markup.main.blockquote/,
        argument.list*/,
        argument.list*/,
      ]
    - match: '(\\)startquotation\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        markup.main.quotation/,
        argument.list*/,
        argument.list*/,
      ]
    - match: '(\\)startaside\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        markup.main.aside/,
        argument.list*/,
        argument.list*/,
      ]
    - match: '(\\)startspeech\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        markup.main.speech/,
        argument.list*/,
        argument.list*/,
      ]

  markup.main.quote/:
    - match: ''
      set:
        - meta_content_scope: markup.quote.block.context
        - match: '(?=\\stopquote\b)'
          pop: true
        - include: main
  markup.main.blockquote/:
    - match: ''
      set:
        - meta_content_scope: markup.quote.block.context
        - match: '(?=\\stopblockquote\b)'
          pop: true
        - include: main
  markup.main.quotation/:
    - match: ''
      set:
        - meta_content_scope: markup.quote.block.context
        - match: '(?=\\stopquotation\b)'
          pop: true
        - include: main
  markup.main.aside/:
    - match: ''
      set:
        - meta_content_scope: markup.quote.block.context
        - match: '(?=\\stopaside\b)'
          pop: true
        - include: main
  markup.main.speech/:
    - match: ''
      set:
        - meta_content_scope: markup.quote.block.context
        - match: '(?=\\stopspeech\b)'
          pop: true
        - include: main

  #D We can have toggles:
  #D
  #D \startitemize
  #D   \startitem
  #D     at the start of a group: \type{... {\em ...} ...},
  #D   \stopitem \startitem
  #D     in the middle of a group: \type{... {... \em ...} ...},
  #D   \stopitem \startitem
  #D     at the start of an implicit group:
  #D     \type{\bTABLE\bTR\bTC \em ... \eTC\eTR\eTABLE}.
  #D   \stopitem  \startitem
  #D     in the middle of an implicit group:
  #D     \type{\bTABLE\bTR\bTC ... \em ... \eTC\eTR\eTABLE}.
  #D   \stopitem
  #D \stopitemize
  #D
  #D We also have the commands \type{\emph} and co.\ which are chameleons, in
  #D that they can be used as toggles \type{{\emph ...}} or delimited as
  #D \type{\emph{...}}. And again we can have explicit grouping \type{{...}} or
  #D implicit grouping \type{\start<...> ... \stop<...>}.
  #D
  #D The approach we take to handle all this variety is to keep it as simple as
  #D possible, by making reasonable assumptions about common usage. So for
  #D example, whilst \type{lorem {ipsum \em dolor} sit} is possible at the
  #D \TeX\ level, we assume that you place the toggle at the start of the
  #D group \type{lorem ipsum {\em dolor} sit}.
  markup.font:
    - include: markup.command
    - include: markup.toggle

  markup.toggle:
    - include: scoping.markup

  markup.command:
    - include: markup.command.emphasis
    - include: markup.command.boldface
    - include: markup.command.italic
    - include: markup.command.slanted
    - include: markup.command.bold-italic
    - include: markup.command.bold-slanted
    - include: markup.command.sans-bold
    - include: markup.command.typewriter
    - include: markup.command.typewriter-bold

  markup.command.emphasis:
    - match: '(\\)emph\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.emphasis*/
  markup.command.boldface:
    - match: '(\\)(small)?bold\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.boldface*/
  markup.command.italic:
    - match: '(\\)italic\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.italic*/
  markup.command.slanted:
    - match: '(\\)(small)?slanted\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.slanted*/
  markup.command.bold-italic:
    - match: '(\\)(small)?(bolditalic|italicbold)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.bold-italic*/
  markup.command.bold-slanted:
    - match: '(\\)(small)?(boldslanted|slantedbold)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.bold-slanted*/
  markup.command.sans-bold:
    - match: '(\\)sansbold\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.sans-bold*/
  markup.command.typewriter:
    - match: '(\\)mono\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.typewriter*/
  markup.command.typewriter-bold:
    - match: '(\\)monobold\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.typewriter-bold*/


  table:
    - match: '(\\)start(table|tabulate)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.template-or-name*/,
      ]
    - match: '(\\)(REF|ReFormat)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group*/,
        argument.list.template*/,
      ]
    - match: '(\\)Use\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group*/,
        argument.list.template*/,
        argument.group.with-integers*/,
      ]


  verbatim:
    - include: verbatim.inline
    - include: verbatim.block
    - include: verbatim.buffer
    - include: verbatim.hiding

  verbatim.inline:
    - match: '(\\)type?\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.group-or-angles-or-delim.verbatim*/,
        argument.list*/,
      ]
    - match: '(\\)(tex|arg|mat|dis|astype|verbatim(string)?)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group.verbatim*/

  #D Should we embed the appropriate syntaxes inside \type{TEX}, \type{LUA},
  #D etc.? Hmm.
  verbatim.block:
    - match: '(\\)start(typing)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        verbatim.main/,
        argument.list*/,
      ]
    - match: '(\\)startTEX\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        verbatim.main.TEX/,
        argument.list*/,
      ]
    - match: '(\\)startLUA\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        verbatim.main.LUA/,
        argument.list*/,
      ]
    - match: '(\\)startXML\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        verbatim.main.XML/,
        argument.list*/,
      ]
    - match: '(\\)startPARSEDXML\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        verbatim.main.PARSEDXML/,
        argument.list*/,
      ]
    - match: '(\\)startMP\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        verbatim.main.MP/,
        argument.list*/,
      ]

  verbatim.main/:
    - match: ''
      set:
        - meta_include_prototype: false
        - meta_content_scope: markup.raw.block.context
        - match: '(?=\\stoptyping\b)'
          pop: true
  verbatim.main.TEX/:
    - match: ''
      set:
        - meta_include_prototype: false
        - meta_content_scope: markup.raw.block.context
        - match: '(?=\\stopTEX\b)'
          pop: true
  verbatim.main.LUA/:
    - match: ''
      set:
        - meta_include_prototype: false
        - meta_content_scope: markup.raw.block.context
        - match: '(?=\\stopLUA\b)'
          pop: true
  verbatim.main.XML/:
    - match: ''
      set:
        - meta_include_prototype: false
        - meta_content_scope: markup.raw.block.context
        - match: '(?=\\stopXML\b)'
          pop: true
  verbatim.main.PARSEDXML/:
    - match: ''
      set:
        - meta_include_prototype: false
        - meta_content_scope: markup.raw.block.context
        - match: '(?=\\stopPARSEDXML\b)'
          pop: true
  verbatim.main.MP/:
    - match: ''
      set:
        - meta_include_prototype: false
        - meta_content_scope: markup.raw.block.context
        - match: '(?=\\stopMP\b)'
          pop: true

  verbatim.buffer:
    - match: '(\\)startbuffer\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        verbatim.main.buffer/,
        argument.list*/,
      ]
  verbatim.main.buffer/:
    - match: ''
      set: verbatim.main.buffer.aux/
  verbatim.main.buffer.aux/:
    - meta_include_prototype: false
    - meta_content_scope: meta.environment.buffer.context markup.raw.block.context
    - match: '(?=\\stopbuffer\b)'
      pop: true

  verbatim.hiding:
    - match: '(\\)start(hiding)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: verbatim.hiding.main/
  verbatim.hiding.main/:
    - meta_content_scope: comment.block.hiding.context
    - include: generic.pop-if-stop-match-two/


  # #D Should we bother trying to handle \type{\unprotect ... \protect}, or
  # #D \type{\startasciimode ... \stopasciimode}? It would be nice to handle
  # #D \quote{protect} decently.
  # catcode:
  #   - include: catcode.protect
  # # - include: catcode.asciimode
  #
  # catcode.protect:
  #   - match: '(\\)unprotect\b'
  #     captures:
  #       0: support.function.context meta.control-word.context meta.structure.start.context
  #       1: punctuation.definition.backslash.context
  #   # push: catcode.protect.main/
  #   - match: '(\\)protect\b'
  #     captures:
  #       0: support.function.context meta.control-word.context meta.structure.stop.context
  #       1: punctuation.definition.backslash.context


  heading:
    - include: heading.inline
    - include: heading.block

  heading.inline:
    - match: '(\\)part\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - match: '(?=\[[^=]*?\])'
          set: [
            argument.group.part*/,
            argument.group.with-integers-only*/,
            argument.list.reference*/,
          ]
        - match: '(?=\[)'
          set: argument.list.part*/
        - match: '(?=\{)'
          set: [
            argument.group.part*/,
            argument.group.with-integers-only*/
          ]
        - include: generic.gobble-whitespace-or-pop/
    - match: '(\\)(chapter|title)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - match: '(?=\[[^=]*?\])'
          set: [
            argument.group.chapter*/,
            argument.group.with-integers-only*/,
            argument.list.reference*/,
          ]
        - match: '(?=\[)'
          set: argument.list.chapter*/
        - match: '(?=\{)'
          set: [
            argument.group.chapter*/,
            argument.group.with-integers-only*/
          ]
        - include: generic.gobble-whitespace-or-pop/
    - match: '(\\)(section|subject)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - match: '(?=\[[^=]*?\])'
          set: [
            argument.group.section*/,
            argument.group.with-integers-only*/,
            argument.list.reference*/,
          ]
        - match: '(?=\[)'
          set: argument.list.section*/
        - match: '(?=\{)'
          set: [
            argument.group.section*/,
            argument.group.with-integers-only*/
          ]
        - include: generic.gobble-whitespace-or-pop/
    - match: '(\\)sub(section|subject)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - match: '(?=\[[^=]*?\])'
          set: [
            argument.group.subsection*/,
            argument.group.with-integers-only*/,
            argument.list.reference*/,
          ]
        - match: '(?=\[)'
          set: argument.list.subsection*/
        - match: '(?=\{)'
          set: [
            argument.group.subsection*/,
            argument.group.with-integers-only*/
          ]
        - include: generic.gobble-whitespace-or-pop/
    - match: '(\\)subsub(section|subject)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - match: '(?=\[[^=]*?\])'
          set: [
            argument.group.sub2section*/,
            argument.group.with-integers-only*/,
            argument.list.reference*/,
          ]
        - match: '(?=\[)'
          set: argument.list.sub2section*/
        - match: '(?=\{)'
          set: [
            argument.group.sub2section*/,
            argument.group.with-integers-only*/
          ]
        - include: generic.gobble-whitespace-or-pop/
    - match: '(\\)subsubsub(section|subject)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - match: '(?=\[[^=]*?\])'
          set: [
            argument.group.sub3section*/,
            argument.group.with-integers-only*/,
            argument.list.reference*/,
          ]
        - match: '(?=\[)'
          set: argument.list.sub3section*/
        - match: '(?=\{)'
          set: [
            argument.group.sub3section*/,
            argument.group.with-integers-only*/
          ]
        - include: generic.gobble-whitespace-or-pop/
    - match: '(\\)subsubsubsub(section|subject)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push:
        - match: '(?=\[[^=]*?\])'
          set: [
            argument.group.sub4section*/,
            argument.group.with-integers-only*/,
            argument.list.reference*/,
          ]
        - match: '(?=\[)'
          set: argument.list.sub4section*/
        - match: '(?=\{)'
          set: [
            argument.group.sub4section*/,
            argument.group.with-integers-only*/
          ]
        - include: generic.gobble-whitespace-or-pop/

  heading.block:
    - match: '(\\)startpart\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.part*/,
      ]
    - match: '(\\)start(chapter|title)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.chapter*/,
      ]
    - match: '(\\)start(section|subject)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.section*/,
      ]
    - match: '(\\)startsub(section|subject)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.subsection*/,
      ]
    - match: '(\\)startsubsub(section|subject)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.sub2section*/,
      ]
    - match: '(\\)startsubsubsub(section|subject)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.sub3section*/,
      ]
    - match: '(\\)startsubsubsubsub(section|subject)\b'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list*/,
        argument.list.sub4section*/,
      ]


  file:
    - include: file.project
    - include: file.input
    - include: file.module

  file.module:
    - match: '(\\)useluamodule\b'
      captures:
        0: meta.control-word.context keyword.control.import.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context
      push: argument.list*/
    - match: '(\\)use(tex)?module\b'
      captures:
        0: meta.control-word.context keyword.control.import.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context
      push: [
        argument.list*/,
        argument.list*/,
        argument.list*/,
      ]
  file.project:
    - match: '(\\)(component|environment|product|project)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.list-or-name.file*/
    - match: '(\\)use(component|environment|product|project)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.list.file*/
    - match: '(\\)start(component|environment|product|project)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.list-or-name.this-file*/
  file.input:
    - match: '(\\)input\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.group-or-name.file*/


  process:
    - match: '(\\)(process(action|firstactioninset|allactionsinset)|rawprocessaction)\b'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.list.apply*/,
        argument.list*/,
      ]


  definition:
    - include: definition.texdef
    - include: definition.define
    - include: definition.parameter

  #D See the comments on \type{template}.
  definition.parameter:
    - match: '(\#|\#{2}|\#{4}|\#{8}|\#{16}|\#{32}|\#{64})[[:digit:]]'
      scope: variable.parameter.context
    - match: '(\#|\#{2}|\#{4}|\#{8}|\#{16}|\#{32}|\#{64})([[:alpha:]]+|\{[^\{\}]+\})'
      scope: variable.parameter.preprocessor.context

  definition.texdef:
    - match: '(\\)starttexdefinition\b'
      captures:
        0: meta.control-word.context meta.structure.start.context storage.type.context
        1: punctuation.definition.backslash.context
      push: [
        argument.name*/,
        argument.do-n-tuple*/,
        argument.expanded*/,
        argument.unexpanded*/,
        argument.global*/,
        argument.spaces*/,
      ]
    - match: '(\\)stoptexdefinition\b'
      captures:
        0: meta.control-word.context meta.structure.stop.context storage.type.context
        1: punctuation.definition.backslash.context
  definition.define:
    - match: '(\\)define(expandable)?\b'
      captures:
        0: meta.control-word.context storage.type.context
        1: punctuation.definition.backslash.context
      push: [
        argument.control-sequence.definition*/,
        argument.list.with-integers-only*/,
      ]


  #D In addition to supporting some high||level constructs, we also try to
  #D handle some lower||level bits and bobs. It's a bit ad hoc in places, but
  #D the results look pretty decent.
  low-level:
    - include: low-level.tex
    - include: low-level.modifier
    - include: low-level.type
    - include: low-level.constant

  low-level.tex:
    - match: '(\\)(u?[egx]?|toks|(math)?char|count|dimen|(mu)?skip)def\b'
      captures:
        0: meta.control-word.context storage.type.context
        1: punctuation.definition.backslash.context
      push: argument.control-sequence.definition*/
    - match: '(\\)(g|global)?let\b'
      captures:
        0: meta.control-word.context storage.type.context
        1: punctuation.definition.backslash.context
      push: [
        argument.equals*/,
        argument.control-sequence.definition*/,
      ]
  low-level.modifier:
    - match: '(\\)(long|outer|global|unexpanded|immediate|the|normalprotected)\b'
      captures:
        0: meta.control-word.context storage.modifier.context
        1: punctuation.definition.backslash.context
  low-level.type:
    - match: '(\\)new(mode|signal|count|systemmode|catcodetable|toks|dimen|box|if|conditional|macro|fraction|every|constant|(mu)?skip|read|write|marks|insert|language|fam(ily)?|help)\b'
      captures:
        0: meta.control-word.context storage.type.context
        1: punctuation.definition.backslash.context
      push: argument.control-sequence.definition*/
    - match: '(\\)setnew(constant|macro)\b'
      captures:
        0: meta.control-word.context storage.type.context
        1: punctuation.definition.backslash.context
      push: argument.control-sequence.definition*/
  low-level.constant:
    - match: '(\\)(zerocount|minus(one|two)|plus(one|two|three|four|five|six|seven|eight|nine|ten|sixteen|hundred|twohundred|cxxvii|cxxviii|cclv|cclvi|thousand|tenthousand|twentythousand)|zeroskip|(zero|one|halfa?|onebase|scaled|thousand)point|points|(up|down|right|left)rotationangle|empty|relax|maxdimen|maxcount|(zero|one)muskip|muquad|(escape|begingroup|endgroup|mathshift|alignment|endofline|parameter|superscript|subscript|ignore|space|letter|other|active|comment|invalid)catcode|(bottomlevel|simple|hbox|adjustedhbox|vbox|vtop|align|noalign|output|math|discretionary|insert|vcenter|mathchoice|semisimple|mathshift|mathleft|vadjust)groupcode|(char|cat|num|dim|odd|vmode|hmode|mmode|inner|void|hbox|vbox|x|eof|true|false|case|defined|csname|fontchar)ifcode|(batch|nonstop|scroll|errorstop)modecode|(char|hlist|vlist|rule|insert|mark|adjust|ligature|discretionary|whatsit|math|glue|kern|penalty|unset|maths)nodecode|emptytoks|voidbox|(big|med|small)skipamount)\b'
      captures:
        0: meta.control-word.context constant.language.context
        1: punctuation.definition.backslash.context


  control:
    - include: control.word
    - include: control.symbol
    - include: control.active-character

  control.word:
    #D Let's always make alignment arguments adjacent.
    - include: control.word.alignment.adjacent
    - include: control.word.without-alignment
  control.word.without-alignment:
    - include: control.word.conditional
    - include: control.word.generic
  control.word.adjacent:
    - include: control.word.alignment.adjacent
    - include: control.word.conditional.adjacent
    - include: control.word.generic.adjacent
  control.word.math.adjacent:
    - include: control.word.alignment.adjacent
    - include: control.word.conditional.adjacent
    - include: control.word.generic.math.adjacent

  #D What scope should alignment things have? I suppose \type{keyword} is the
  #D best choice.
  control.word.alignment.adjacent:
    - match: '(\\)(NB|[BCHNMR]C|ND|NG|[BCFHLMTV]L|CM|NN|[EHR]Q|[ACFHLMNS]R|CT)\b'
      captures:
        0: meta.control-word.context keyword.operator.alignment.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context
      push: argument.list.adjacent*/

  control.word.conditional:
    - match: '(\\)([[:alpha:]]*doif[[:alpha:]]*(else)?|[[:alpha:]]*doif(else)?[[:alpha:]]*)\b'
      captures:
        0: meta.control-word.context keyword.control.conditional.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context
      push: argument.lists-or-groups*/
    - include: control.word.conditional.common
  control.word.conditional.adjacent:
    - match: '(\\)([[:alpha:]]*doif[[:alpha:]]*(else)?|[[:alpha:]]*doif(else)?[[:alpha:]]*)\b'
      captures:
        0: meta.control-word.context keyword.control.conditional.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context
      push: argument.lists-or-groups.adjacent*/
    - include: control.word.conditional.common
  control.word.conditional.common:
    - match: '(\\)(if[[:alpha:]]*|[[:alpha:]]*(true|false)|loop|repeat|then|or|else|fi)\b'
      captures:
        0: meta.control-word.context keyword.control.conditional.context
        1: punctuation.definition.backslash.context punctuation.definition.keyword.context

  #D The pattern \type{(\\)define[[:alpha:]]*} works remarkably well in almost
  #D all cases. However it is not foolproof. For the moment, we use the below
  #D work around for some known edge cases. If the number of edge cases grows
  #D significantly, then we will need to reconsider this approach.
  control.word.generic:
    - match: '(\\)start[[:alpha:]]*'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.lists-or-groups*/
    - match: '(\\)define(?!dfont)[[:alpha:]]*'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.lists-or-groups*/,
        argument.list.definition*/,
      ]
    - include: control.word.generic.common
    - match: '(\\)[[:alpha:]]+'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.lists-or-groups*/
  control.word.generic.adjacent:
    - match: '(\\)start[[:alpha:]]*'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.lists-or-groups.adjacent*/
    - match: '(\\)define(?!dfont)[[:alpha:]]*'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: [
        argument.lists-or-groups.adjacent*/,
        argument.list.definition.adjacent*/,
      ]
    - include: control.word.generic.common
    - match: '(\\)[[:alpha:]]+'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.lists-or-groups.adjacent*/
  #D Hmm, how should we handle arguments? The context
  #D \type{argument.lists-or-groups.math.adjacent*/} goes for a compromise:
  #D groups are in math mode, while lists are in text mode. Alternatively, in
  #D lists we can have assignments as in text||mode but everything else in math
  #D mode. I think this is the better option overall.
  control.word.generic.math.adjacent:
    - match: '(\\)start[[:alpha:]]*'
      captures:
        0: meta.control-word.context meta.structure.start.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.lists-or-groups.math.adjacent*/
  # - match: '(\\)define(?!dfont)[[:alpha:]]*'
  #   captures:
  #     0: meta.control-word.context support.function.context
  #     1: punctuation.definition.backslash.context
  #   push: [
  #     argument.lists-or-groups.math.adjacent*/,
  #     argument.list.definition.adjacent*/,
  #   ]
    - include: control.word.generic.common
    - match: '(\\)[[:alpha:]]+'
      captures:
        0: meta.control-word.context support.function.context
        1: punctuation.definition.backslash.context
      push: argument.lists-or-groups.math.adjacent*/
  control.word.generic.common:
    - match: '(\\)stop[[:alpha:]]*'
      captures:
        0: meta.control-word.context meta.structure.stop.context support.function.context
        1: punctuation.definition.backslash.context

  control.symbol:
    - match: '(\\)([^[:alpha:]]|$)'
      captures:
        0: constant.character.escape.context
        1: punctuation.definition.backslash.context
  control.active-character:
    - match: '[|~]'
      scope: constant.other.active.context


  scoping:
    - include: scoping.group
  scoping.math:
    - include: scoping.group.math
  scoping.Lua:
    - include: scoping.group.Lua
  scoping.verbatim:
    - include: scoping.group.verbatim
  scoping.markup:
    - include: scoping.group.emphasis
    - include: scoping.group.boldface
    - include: scoping.group.italic
    - include: scoping.group.slanted
    - include: scoping.group.bold-italic
    - include: scoping.group.bold-slanted
    - include: scoping.group.sans-bold
    - include: scoping.group.typewriter
    - include: scoping.group.typewriter-bold

  scoping.group:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      push: scoping.group.main/
  scoping.group.main/:
    - meta_scope: meta.braces.context
    - include: generic.pop-at-group-end/
    - include: main

  scoping.group.math:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      push: scoping.group.math.main/
  scoping.group.math.main/:
    - meta_scope: meta.braces.context
    - include: generic.pop-at-group-end/
    - include: math.main

  scoping.group.Lua:
    - match: '\{'
      push: scoping.group.Lua.main/
  scoping.group.Lua.main/:
    - match: '\}'
      pop: true
    - include: scoping.group.Lua
    - include: Lua.main

  scoping.group.verbatim:
    - match: '\{'
      push: scoping.group.verbatim.main/
  scoping.group.verbatim.main/:
    - meta_include_prototype: false
    - match: '\}'
      pop: true
    - include: scoping.group.verbatim

  scoping.group.emphasis:
    - match: '(\{)\s*((\\)(emph|em))\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: meta.control-word.context support.function.context
        3: punctuation.definition.backslash.context
      push: scoping.group.emphasis.main/
  scoping.group.boldface:
    - match: '(\{)\s*((\\)(boldface|(small)?bold|bf(xx|[xabcd])?))\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.boldface.main/
  scoping.group.italic:
    - match: '(\{)\s*((\\)(italic|it(xx|[xabcd])?))\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.italic.main/
  scoping.group.slanted:
    - match: '(\{)\s*((\\)((small)?slanted|sl(xx|[xabcd])?))\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.slanted.main/
  scoping.group.bold-italic:
    - match: '(\{)\s*((\\)((small)?(bolditalic|italicbold)|bi(xx|[xabcd])?))\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.bold-italic.main/
  scoping.group.bold-slanted:
    - match: '(\{)\s*((\\)((small)?(boldslanted|slantedbold)|bs(xx|[xabcd])?))\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.bold-slanted.main/
  scoping.group.sans-bold:
    - match: '(\{)\s*((\\)sansbold)\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.sans-bold.main/
  scoping.group.typewriter:
    - match: '(\{)\s*((\\)(mono|tt(xx|[xabcd])?))\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.typewriter.main/
  scoping.group.typewriter-bold:
    - match: '(\{)\s*((\\)monobold)\b'
      captures:
        1: punctuation.section.braces.begin.context
        2: support.function.context meta.control-word.context
        3: punctuation.definition.backslash.context
      push: scoping.group.typewriter-bold.main/

  scoping.group.emphasis.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.italic.emphasis.context
    - include: argument.group.main/
  scoping.group.boldface.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.bold.boldface.context
    - include: argument.group.main/
  scoping.group.italic.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.italic.italic.context
    - include: argument.group.main/
  scoping.group.slanted.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.italic.slanted.context
    - include: argument.group.main/
  scoping.group.bold-italic.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.italic.italic.context markup.bold.boldface.context
    - include: argument.group.main/
  scoping.group.bold-slanted.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.italic.slanted.context markup.bold.boldface.context
    - include: argument.group.main/
  scoping.group.sans-bold.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.bold.boldface.context  # markup.sans-serif.context ?
    - include: argument.group.main/
  scoping.group.typewriter.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.raw.inline.context
    - include: argument.group.main/
  scoping.group.typewriter-bold.main/:
    - meta_scope: meta.braces.context
    - meta_content_scope: markup.bold.boldface.context markup.raw.inline.context
    - include: argument.group.main/


  argument.group:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      push: argument.group.main/
  argument.group/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.main/
  argument.group*/:
    - include: argument.group/
    - include: generic.pop-if-no-nearby-group/
  argument.group.adjacent*/:
    - include: generic.pop-if-whitespace/
    - include: argument.group/
    - include: generic.pop/
  argument.groups*/:
    - include: argument.group
    - include: generic.pop-if-no-nearby-group/
  argument.group.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - include: generic.pop-at-group-end/
    - include: main

  argument.group.math:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      push: argument.group.math.main/
  argument.group.math/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.math.main/
  argument.group.math*/:
    - include: argument.group.math/
    - include: generic.pop-if-no-nearby-group/
  argument.group.math.adjacent*/:
    - include: generic.pop-if-whitespace/
    - include: argument.group.math/
    - include: generic.pop/
  argument.group.math.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - include: generic.pop-at-group-end/
    - include: math.main

  argument.group.with-assignments/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.with-assignments.main/
  argument.group.with-assignments*/:
    - include: argument.group.with-assignments/
    - include: generic.pop-if-no-nearby-group/
  argument.group.with-assignments.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - include: generic.group.assignments
    - include: argument.group.main/

  argument.group.with-integers/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.with-integers.main/
  argument.group.with-integers*/:
    - include: argument.group.with-integers/
    - include: generic.pop-if-no-nearby-group/
  argument.group.with-integers.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - include: generic.integer
    - include: argument.group.main/

  #D Special case, should do the job well enough.
  argument.group.with-integers-only/:
    - match: '(\{)\s*([[:digit:]]+)\s*(\})'
      captures:
        0: meta.braces.context meta.environment.argument.context
        1: punctuation.section.braces.begin.context
        2: constant.numeric.context
        3: punctuation.section.braces.begin.context
      pop: true
  argument.group.with-integers-only*/:
    - include: argument.group.with-integers-only/
    - include: generic.gobble-whitespace-or-pop/

  argument.group.quote/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.quote.main/
  argument.group.quote*/:
    - include: argument.group.quote/
    - include: generic.pop-if-no-nearby-group/
  argument.group.quote.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.quote.inline.context
    - include: argument.group.main/

  argument.group.math.outer:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      push: argument.group.math.outer.main/
  argument.group.math.outer/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.math.outer.main/
  argument.group.math.outer*/:
    - include: argument.group.math.outer/
    - include: generic.pop-if-no-nearby-group/
  argument.group.math.outer.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: meta.environment.math.context
    - include: argument.group.math.main/

  argument.group.Lua/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context meta.braces.context
      set: argument.group.Lua.main/
  argument.group.Lua*/:
    - include: argument.group.Lua/
    - include: generic.pop-if-no-nearby-group/
  argument.group.Lua.main/:
    - match: ''
      set: argument.group.Lua.main.aux/
  argument.group.Lua.main.aux/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: source.lua.embedded.context meta.environment.lua.minor.context
    - include: generic.pop-at-group-end/
    - include: scoping.Lua
    - include: Lua.main

  argument.group.verbatim/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.verbatim.main/
  argument.group.verbatim*/:
    - include: argument.group.verbatim/
    - include: generic.pop-if-no-nearby-group/
  argument.group.verbatim.main/:
    - meta_include_prototype: false
    - meta_content_scope: markup.raw.inline.context
    - meta_scope: meta.braces.context meta.environment.argument.context
    - include: generic.pop-at-group-end/
    - include: scoping.verbatim

  argument.group.file/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.file.main/
  argument.group.file*/:
    - include: argument.group.file/
    - include: generic.pop-if-no-nearby-group/
  argument.group.file.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: meta.file-name.context
    - include: argument.group.main/

  argument.group.part*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set:
        - meta_scope: meta.braces.context meta.environment.argument.context
        - meta_content_scope: meta.title.context entity.name.section.part.context markup.heading.context
        - include: argument.group.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.chapter*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set:
        - meta_scope: meta.braces.context meta.environment.argument.context
        - meta_content_scope: meta.title.context entity.name.section.chapter.context markup.heading.context
        - include: argument.group.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.section*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set:
        - meta_scope: meta.braces.context meta.environment.argument.context
        - meta_content_scope: meta.title.context entity.name.section.section.context markup.heading.context
        - include: argument.group.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.subsection*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set:
        - meta_scope: meta.braces.context meta.environment.argument.context
        - meta_content_scope: meta.title.context entity.name.section.subsection.context markup.heading.context
        - include: argument.group.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.sub2section*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set:
        - meta_scope: meta.braces.context meta.environment.argument.context
        - meta_content_scope: meta.title.context entity.name.section.sub2section.context markup.heading.context
        - include: argument.group.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.sub3section*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set:
        - meta_scope: meta.braces.context meta.environment.argument.context
        - meta_content_scope: meta.title.context entity.name.section.sub3section.context markup.heading.context
        - include: argument.group.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.sub4section*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set:
        - meta_scope: meta.braces.context meta.environment.argument.context
        - meta_content_scope: meta.title.context entity.name.section.sub4section.context markup.heading.context
        - include: argument.group.main/
    - include: generic.pop-if-no-nearby-group/

  argument.group.emphasis*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.emphasis.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.boldface*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.boldface.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.italic*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.italic.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.slanted*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.slanted.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.bold-italic*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.bold-italic.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.bold-slanted*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.bold-slanted.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.sans-bold*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.sans-bold.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.typewriter*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.typewriter.main/
    - include: generic.pop-if-no-nearby-group/
  argument.group.typewriter-bold*/:
    - match: '\{'
      scope: punctuation.section.braces.begin.context
      set: argument.group.typewriter-bold.main/
    - include: generic.pop-if-no-nearby-group/

  argument.group.emphasis.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.italic.emphasis.context
    - include: argument.group.main/
  argument.group.boldface.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.bold.boldface.context
    - include: argument.group.main/
  argument.group.italic.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.italic.italic.context
    - include: argument.group.main/
  argument.group.slanted.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.italic.slanted.context
    - include: argument.group.main/
  argument.group.bold-italic.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.italic.italic.context markup.bold.boldface.context
    - include: argument.group.main/
  argument.group.bold-slanted.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.italic.slanted.context markup.bold.boldface.context
    - include: argument.group.main/
  argument.group.sans-bold.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.bold.boldface.context
    - include: argument.group.main/
  argument.group.typewriter.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.raw.inline.context
    - include: argument.group.main/
  argument.group.typewriter-bold.main/:
    - meta_scope: meta.braces.context meta.environment.argument.context
    - meta_content_scope: markup.bold.boldface.context markup.raw.inline.context
    - include: argument.group.main/

  #D A flavour of list we could add is \quote{apply}s, which look like
  #D \type{[..,..=>..,..]} with the \type{=>} symbols.
  argument.list:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      push: argument.list.main/
  argument.list/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.main/
  argument.list*/:
    - include: argument.list/
    - include: generic.pop-if-no-nearby-list/
  argument.list.adjacent*/:
    - include: generic.pop-if-whitespace/
    - include: argument.list/
    - include: generic.pop/
  argument.lists*/:
    - include: argument.list
    - include: generic.pop-if-no-nearby-list/
  argument.list.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - include: generic.pop-at-list-end/
    - include: generic.list.assignments
    - include: generic.dimension
    - include: main

  argument.list.apply:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      push: argument.list.apply.main/
  argument.list.apply/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.apply.main/
  argument.list.apply*/:
    - include: argument.list.apply/
    - include: generic.pop-if-no-nearby-list/
  argument.list.apply.adjacent*/:
    - include: generic.pop-if-whitespace/
    - include: argument.list.apply/
    - include: generic.pop/
  argument.lists.apply*/:
    - include: argument.list.apply
    - include: generic.pop-if-no-nearby-list/
  argument.list.apply.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - include: generic.pop-at-list-end/
    - include: generic.list.processors
  # - include: generic.dimension
    - include: main

  argument.list.math:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      push: argument.list.math.main/
  argument.list.math/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.math.main/
  argument.list.math*/:
    - include: argument.list.math/
    - include: generic.pop-if-no-nearby-list/
  argument.list.math.adjacent*/:
    - include: generic.pop-if-whitespace/
    - include: argument.list.math/
    - include: generic.pop/
  argument.lists.math*/:
    - include: argument.list.math
    - include: generic.pop-if-no-nearby-list/
  argument.list.math.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - include: generic.pop-at-list-end/
    - include: generic.list.assignments
    - include: generic.dimension
    - include: math.main

  argument.list.file/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.file.main/
  argument.list.file*/:
    - include: argument.list.file/
    - include: generic.pop-if-no-nearby-list/
  argument.list.file.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - meta_content_scope: meta.file-name.context
    - include: generic.pop-at-list-end/
    - include: main

  argument.list.this-file/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.this-file.main/
  argument.list.this-file*/:
    - include: argument.list.this-file/
    - include: generic.pop-if-no-nearby-list/
  argument.list.this-file.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - meta_content_scope: meta.this-file-name.context
    - include: generic.pop-at-list-end/
    - include: main

  argument.list.definition/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.definition.main/
  argument.list.definition*/:
    - include: argument.list.definition/
    - include: generic.pop-if-no-nearby-list/
  argument.list.definition.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - meta_content_scope: entity.name.function.other.context
    - include: generic.pop-at-list-end/
    - include: main

  #D Special case, should do the job well enough.
  argument.list.with-integers-only/:
    - match: '(\[)\s*([[:digit:]]+)\s*(\])'
      captures:
        0: meta.brackets.context meta.environment.argument.context
        1: punctuation.section.brackets.begin.context
        2: constant.numeric.context
        3: punctuation.section.brackets.begin.context
      pop: true
  argument.list.with-integers-only*/:
    - include: argument.list.with-integers-only/
    - include: generic.gobble-whitespace-or-pop/

  argument.list.part*/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set:
        - meta_scope: meta.brackets.context meta.environment.argument.context
        - match: '\b(title)\s*(=)'
          captures:
            1: variable.parameter.context
            2: keyword.operator.assignment.context
          push:
            - meta_content_scope: meta.value.context meta.title.context entity.name.section.part.context markup.heading.context
            - include: argument.list.heading.common/
        - include: argument.list.main/
    - include: generic.pop-if-no-nearby-list/
  argument.list.chapter*/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set:
        - meta_scope: meta.brackets.context meta.environment.argument.context
        - match: '\b(title)\s*(=)'
          captures:
            1: variable.parameter.context
            2: keyword.operator.assignment.context
          push:
            - meta_content_scope: meta.value.context meta.title.context entity.name.section.chapter.context markup.heading.context
            - include: argument.list.heading.common/
        - include: argument.list.main/
    - include: generic.pop-if-no-nearby-list/
  argument.list.section*/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set:
        - meta_scope: meta.brackets.context meta.environment.argument.context
        - match: '\b(title)\s*(=)'
          captures:
            1: variable.parameter.context
            2: keyword.operator.assignment.context
          push:
            - meta_content_scope: meta.value.context meta.title.context entity.name.section.section.context markup.heading.context
            - include: argument.list.heading.common/
        - include: argument.list.main/
    - include: generic.pop-if-no-nearby-list/
  argument.list.subsection*/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set:
        - meta_scope: meta.brackets.context meta.environment.argument.context
        - match: '\b(title)\s*(=)'
          captures:
            1: variable.parameter.context
            2: keyword.operator.assignment.context
          push:
            - meta_content_scope: meta.value.context meta.title.context entity.name.section.subsection.context markup.heading.context
            - include: argument.list.heading.common/
        - include: argument.list.main/
    - include: generic.pop-if-no-nearby-list/
  argument.list.sub2section*/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set:
        - meta_scope: meta.brackets.context meta.environment.argument.context
        - match: '\b(title)\s*(=)'
          captures:
            1: variable.parameter.context
            2: keyword.operator.assignment.context
          push:
            - meta_content_scope: meta.value.context meta.title.context entity.name.section.sub2section.context markup.heading.context
            - include: argument.list.heading.common/
        - include: argument.list.main/
    - include: generic.pop-if-no-nearby-list/
  argument.list.sub3section*/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set:
        - meta_scope: meta.brackets.context meta.environment.argument.context
        - match: '\b(title)\s*(=)'
          captures:
            1: variable.parameter.context
            2: keyword.operator.assignment.context
          push:
            - meta_content_scope: meta.value.context meta.title.context entity.name.section.sub3section.context markup.heading.context
            - include: argument.list.heading.common/
        - include: argument.list.main/
    - include: generic.pop-if-no-nearby-list/
  argument.list.sub4section*/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set:
        - meta_scope: meta.brackets.context meta.environment.argument.context
        - match: '\b(title)\s*(=)'
          captures:
            1: variable.parameter.context
            2: keyword.operator.assignment.context
          push:
            - meta_content_scope: meta.value.context meta.title.context entity.name.section.sub4section.context markup.heading.context
            - include: argument.list.heading.common/
        - include: argument.list.main/
    - include: generic.pop-if-no-nearby-list/
  argument.list.heading.common/:
    - include: generic.list.pop-at-end-of-assignment/
    - include: main

  argument.list.reference/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.reference.main/
  argument.list.reference*/:
    - include: argument.list.reference/
    - include: generic.pop-if-no-nearby-list/
  argument.list.reference.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - meta_content_scope: meta.reference.context
    - include: generic.pop-at-list-end/
    - include: main

  argument.list.template/:
    - match: '\['
      scope: punctuation.section.brackets.begin.context
      set: argument.list.template.main/
  argument.list.template*/:
    - include: argument.list.template/
    - include: generic.pop-if-no-nearby-list/
  argument.list.template.main/:
    - meta_scope: meta.brackets.context meta.environment.argument.context
    - include: argument.list.template.keys
    - include: generic.pop-at-list-end/

  argument.list.template-or-name/:
    - match: '\['
      scope: meta.brackets.context punctuation.section.brackets.begin.context
      set: argument.list.template-or-name.main/
  argument.list.template-or-name*/:
    - include: argument.list.template-or-name/
    - include: generic.pop-if-no-nearby-list/
  argument.list.template-or-name.main/:
    - match: '(?=\s*[^\]]*\|)'
      set: argument.list.template.main/
    - match: ''
      set: argument.list.main/

  #D We (ab)use some of the usual scopes.
  argument.list.template.keys:
    - match: '\|'
      scope: punctuation.separator.column.context
    - match: '[lcrx]'
      scope: variable.parameter.table.context
    - match: '[wp]'
      scope: variable.parameter.table.context
    # push: argument.parens.with-dimensions*/
    #D The space is important, apparently.
    - match: '([nNqQ])\s*([[:digit:]]+)\.([[:digit:]]+) '
      captures:
        1: variable.parameter.table.context
        2: constant.numeric.context
        3: constant.numeric.context
    - match: '([mM]|[BISRT])'
      scope: keyword.other.table.context
    - match: '[f]'
      scope: keyword.other.table.context
      push: argument.group*/
    - match: '([sojk])\s*([[:digit:]])'
      captures:
        1: support.function.table.context
        2: constant.numeric.context
    - match: '[sojk]'
      scope: support.function.table.context
      push: argument.group.with-integers*/
    - include: generic.dimension
    - include: main

  argument.list-or-group:
    - include: argument.list
    - include: argument.group
  argument.lists-or-groups*/:
    - include: argument.list-or-group
    - include: generic.pop-if-no-nearby-list-or-group/
  argument.lists-or-groups.adjacent*/:
    - include: generic.pop-if-whitespace/
    - include: argument.list-or-group
    - include: generic.pop/

  argument.list-or-group.math:
  # - include: argument.list.math
    - include: argument.list
    - include: argument.group.math
  argument.lists-or-groups.math*/:
    - include: argument.list-or-group.math
    - include: generic.pop-if-no-nearby-list-or-group/
  argument.lists-or-groups.math.adjacent*/:
    - include: generic.pop-if-whitespace/
    - include: argument.list-or-group.math
    - include: generic.pop/

  argument.group-or-name.file*/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - match: '(?=\{)'
      set: argument.group.file*/
    - match: '(?=.)'
      set: argument.name.file*/
  argument.list-or-name.file*/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - match: '(?=\[)'
      set: argument.list.file*/
    - match: '(?=.)'
      set: argument.name.file*/
  argument.list-or-name.this-file*/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - match: '(?=\[)'
      set: argument.list.this-file*/
    - match: '(?=.)'
      set: argument.name.this-file*/

  argument.angles.verbatim/:
    - match: '<<'
      scope: punctuation.section.double-angle.begin.context
      set: argument.angles.verbatim.main/
  argument.angles.verbatim.main/:
    - meta_include_prototype: false
    - meta_content_scope: markup.raw.inline.context
    - meta_scope: meta.double-angle.context
    - match: '>>'
      scope: punctuation.section.double-angle.end.context
      pop: true

  argument.delim.verbatim/:
    - match: '({{verbatim}})'
      scope: punctuation.section.delim.begin.context
      set: argument.delim.verbatim.main/
  argument.delim.verbatim.main/:
    - meta_include_prototype: false
    - meta_content_scope: markup.raw.inline.context
    - meta_scope: meta.delim.context
    - match: '\1'
      scope: punctuation.section.delim.end.context
      pop: true

  argument.group-or-angles-or-delim.verbatim*/:
    - include: argument.group.verbatim/
    - include: argument.angles.verbatim/
    - include: argument.delim.verbatim/
    - include: generic.gobble-whitespace-or-pop/

  argument.control-word.definition/:
    - match: '(\\)[[:alpha:]]+'
      captures:
        0: meta.control-word.context entity.name.function.context
        1: punctuation.definition.backslash.context
      pop: true
  argument.control-symbol.definition/:
    - match: '(\\)([^[:alpha:]]|$)'
      captures:
        0: entity.name.function.context
        1: punctuation.definition.backslash.context
      pop: true
  argument.control-sequence.definition/:
    - include: argument.control-word.definition/
    - include: argument.control-symbol.definition/
  argument.control-sequence.definition*/:
    - include: argument.control-sequence.definition/
    - include: generic.pop-if-no-nearby-control-sequence/

  argument.integer:
    - include: generic.integer
  argument.integer/:
    - include: generic.integer/
  argument.integer*/:
    - include: generic.integer/
    - include: generic.gobble-whitespace-or-pop/

  argument.equals/:
    - match: '='
      scope: keyword.operator.assignment.context
      pop: true
  argument.equals*/:
    - include: argument.equals/
    - include: generic.gobble-whitespace-or-pop/

  argument.spaces/:
    - match: '\b(no)?spaces\b'
      scope: storage.modifier.spaces.context
      pop: true
  argument.global/:
    - match: '\bglobal\b'
      scope: storage.modifier.global.context
      pop: true
  argument.unexpanded/:
    - match: '\bunexpanded\b'
      scope: storage.modifier.unexpanded.context
      pop: true
  argument.expanded/:
    - match: '\bexpanded\b'
      scope: storage.modifier.expanded.context
      pop: true
  argument.do-n-tuple/:
    - match: '\b(single|double|triple|quadruple|quintuple|sixtuple)(argument|empty)\b'
      scope: storage.modifier.n-tuple.context
      pop: true
  argument.name/:
    - match: '{{setup}}+'
      scope: entity.name.function.context
      pop: true
  argument.name.file/:
    - match: '{{setup}}+'
      scope: meta.file-name.context
      pop: true
  argument.name.this-file/:
    - match: '{{setup}}+'
      scope: meta.this-file-name.context
      pop: true

  argument.spaces*/:
    - include: argument.spaces/
    - include: generic.gobble-whitespace-or-pop/
  argument.global*/:
    - include: argument.global/
    - include: generic.gobble-whitespace-or-pop/
  argument.unexpanded*/:
    - include: argument.unexpanded/
    - include: generic.gobble-whitespace-or-pop/
  argument.expanded*/:
    - include: argument.expanded/
    - include: generic.gobble-whitespace-or-pop/
  argument.do-n-tuple*/:
    - include: argument.do-n-tuple/
    - include: generic.gobble-whitespace-or-pop/
  argument.name*/:
    - include: argument.name/
    - include: generic.gobble-whitespace-or-pop/
  argument.name.file*/:
    - include: argument.name.file/
    - include: generic.gobble-whitespace-or-pop/
  argument.name.this-file*/:
    - include: argument.name.this-file/
    - include: generic.gobble-whitespace-or-pop/


  generic.pop-if-no-group/:
    - match: '(?=[^\{])'
      pop: true
  generic.pop-if-no-list/:
    - match: '(?=[^\[])'
      pop: true
  generic.pop-if-no-parens/:
    - match: '(?=[^\(])'
      pop: true
  generic.pop-if-no-list-or-group/:
    - match: '(?=[^\[\{])'
      pop: true
  generic.pop-if-no-control-sequence/:
    - match: '(?=[^\\])'
      pop: true
  generic.pop-if-blank-line/:
    - match: '(?=^\s*$\n?)'
      pop: true
  generic.pop-if-whitespace/:
    - match: '(?=\s)'
      pop: true
  generic.pop/:
    - match: ''
      pop: true
  generic.pop-if-stop-match-two/:
    - match: '(?=\\stop\2\b)'
      pop: true

  generic.gobble-whitespace:
    - match: '\s+'
  generic.gobble-whitespace-or-pop-if-blank-line/:
    - include: generic.pop-if-blank-line/
    - include: generic.gobble-whitespace
  generic.gobble-whitespace-or-pop/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - include: generic.pop/

  generic.pop-if-no-nearby-group/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - include: generic.pop-if-no-group/
  generic.pop-if-no-nearby-list/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - include: generic.pop-if-no-list/
  generic.pop-if-no-nearby-list-or-group/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - include: generic.pop-if-no-list-or-group/
  generic.pop-if-no-nearby-parens/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - include: generic.pop-if-no-parens/
  generic.pop-if-no-nearby-control-sequence/:
    - include: generic.gobble-whitespace-or-pop-if-blank-line/
    - include: generic.pop-if-no-control-sequence/

  generic.pop-at-group-end/:
    - match: '\}'
      scope: punctuation.section.braces.end.context
      pop: true
  generic.pop-at-list-end/:
    - match: '\]'
      scope: punctuation.section.brackets.end.context
      pop: true
  generic.pop-at-parens-end/:
    - match: '\)'
      scope: punctuation.section.parens.end.context
      pop: true
  generic.list.pop-at-end-of-assignment/:
    - include: generic.pop-at-comma/
    - match: '(?=\])'
      pop: true
  generic.group.pop-at-end-of-assignment/:
    - include: generic.pop-at-comma/
    - match: '(?=\})'
      pop: true
  generic.pop-at-comma/:
    - match: ','
      scope: punctuation.separator.comma.context
      pop: true

  generic.integer:
    - match: '[[:digit:]]+'
      scope: constant.numeric.context
  generic.integer/:
    - match: '[[:digit:]]+'
      scope: constant.numeric.context
      pop: true
  generic.real:
    - match: '([[:digit:]]+|[[:digit:]]*\.[[:digit:]]+)'
      scope: constant.numeric.context
  generic.real/:
    - match: '([[:digit:]]+|[[:digit:]]*\.[[:digit:]]+)'
      scope: constant.numeric.context
      pop: true
  generic.dimension:
    - match: '([[:digit:]]+|[[:digit:]]*\.[[:digit:]]+)(pt|pc|in|bp|cm|mm|dd|cc|sp|em|ex)\b'
      captures:
        1: constant.numeric.context
        2: keyword.other.unit.context
  generic.dimension/:
    - match: '([[:digit:]]+|[[:digit:]]*\.[[:digit:]]+)(pt|pc|in|bp|cm|mm|dd|cc|sp|em|ex)\b'
      captures:
        1: constant.numeric.context
        2: keyword.other.unit.context
      pop: true

  generic.list.assignments:
    - match: '\b(reference)\s*(=)'
      captures:
        1: variable.parameter.context
        2: keyword.operator.assignment.context
      push:
        - meta_content_scope: meta.value.context meta.reference.context
        - include: generic.list.pop-at-end-of-assignment/
        - include: main
  # - match: '\b(title)\s*(=)'
  #   captures:
  #     1: variable.parameter.context
  #     2: keyword.operator.assignment.context
  #   push:
  #     - meta_content_scope: meta.value.context entity.name.section.other.context markup.heading.context meta.title.context
  #     - include: generic.list.pop-at-end-of-assignment/
  #     - include: main
    - match: '({{key}}*)\s*(=)'
      captures:
        1: variable.parameter.context
        2: keyword.operator.assignment.context
      push:
        - meta_content_scope: meta.value.context
        - include: generic.list.pop-at-end-of-assignment/
        - include: generic.dimension
        - include: main
    - include: generic.assignment.comma

  generic.list.processors:
    - match: '({{key}}*)\s*(=>)'
      #D Hmm, I suppose calling this an \quote{assignment} is reasonable.
      captures:
        1: variable.parameter.context
        2: keyword.operator.assignment.context
      push:
        - meta_content_scope: meta.value.context
        - include: generic.list.pop-at-end-of-assignment/
        - include: generic.dimension
        - include: main
    - include: generic.assignment.comma

  generic.group.assignments:
    - match: '({{key}}*)\s*(=)'
      captures:
        1: variable.parameter.context
        2: keyword.operator.assignment.context
      push:
        - meta_content_scope: meta.value.context
        - include: generic.group.pop-at-end-of-assignment/
        - include: generic.dimension
        - include: main
    - include: generic.assignment.comma

  generic.assignment.comma:
    - match: ','
      scope: punctuation.separator.comma.context
