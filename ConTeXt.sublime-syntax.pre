%YAML 1.2
---
# See http://www.sublimetext.com/docs/3/syntax.html for a good, albeit
# incomplete, explanation of how this syntax works.
name: ConTeXt
file_extensions: tex
scope: text.tex.context
# -----------------------------------------------------------------------------
# VARIABLES
# -----------------------------------------------------------------------------
# Variables are nice! In addition to the ones here, we also have some variables
# in syntax_pre_process.json - to reference them, simply type {{@var_name}}.
# Then the python preprocessor will replace them with the corresponding values.
variables:
  unit:       '(pt|pc|in|bp|cm|mm|cc|sp|em|ex)' # valid TeX units
  uns_int:    '\d+'
  uns_real:   '(\d+\.\d*|\d*\.\d+)'
  uns_number: '({{uns_real}}|{{uns_int}})'
  number:     '[\+\-]*{{uns_number}}'
  # To be continued: this should list all (most?) of the Lua functions that
  # ConTeXt provides, so we can highlight them appropriately inside Lua code.
  lua_context_functions: '(tex\.s?print)|context'
  # Also needs some TLC, but eventually these variables (or ones like them)
  # should let us highlight TikZ syntax nicely. The problem is, the TikZ
  # grammar is pretty big, and I'm not well versed enough in it to know how
  # best to highlight it.
  tikz_path_op:  '(draw|fill(draw)?|path|node)'
  tikz_draw_cmd: '(--|rectangle|node)'

# -----------------------------------------------------------------------------
# MAIN
# -----------------------------------------------------------------------------
# A note on the naming convention I've been using for contexts:
#   * if it ends in a '/' then it pops off when (and only when) it finds a
#       match (what a 'match' means will depend on the particular context, but
#       e.g. 'group/' is looking to match something like '{...}')
#   * ending in '*/' means the same as '/', except that it will pop off if it
#       can't find any match - it is optional. (I wanted to use '?' for this
#       purpose, but it is not allowed in a context name)
#   * otherwise it never pops, it just remains at the current level of scope -
#       generally these are the ones intended for 'include'-ing (which you can
#       think of as just 'copy-paste'-ing that contexts code wherever the
#       include statement occurs)
# Oh, one more note: the characters that can be used in a context name are
# quite generous - you can use more of the ASCII character set than you'd
# expect! So I've been using '.' to pretend that I have namespaces, but don't
# be fooled, there is only the global namespace (as far as I know).
contexts:
  main:
  - include: tex
  - include: lua
  - include: tikz
  - include: math
  - include: ConTeXt
  - include: default

  prototype:
  - include: comments

  comments:
  # Because these matches are applied one line at a time, we can use this very
  # simple regex instead of something like '\%.*?$'.
  - match: '\%.*'
    scope: {{@COMMENT}}

# -----------------------------------------------------------------------------
# TEX
# -----------------------------------------------------------------------------
  tex:
  - include: tex.def

  tex.def:
  - match: '\\[egx]?def\b'
    scope: {{@TEX_DEF}}
    # Things are pushed onto the stack in the order they are written, so that
    # after this 'push', 'tex.def.assignable/' will be on top of the stack,
    # with 'tex.def.parameters*/' just below it and 'tex.def.group/' below
    # that.
    push: [
      tex.def.group/,
      tex.def.parameters*/,
      tex.def.assignable/,
    ]

  tex.def.assignable/:
  # although usually you '\def' a control word, it is also possible to '\def' a
  # control symbol or an active character
  - match: '\\[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
    pop: true
  - match: '\\[^a-zA-Z]'
    scope: {{@CONTROL_SYMBOL}}
    pop: true
  - match: '[^\s]'
    scope: {{@ACTIVE_CHARACTER}}
    pop: true

  tex.def.parameters*/:
  - match: '\#([1-9]|(?=\{))'
    scope: {{@TEX_PARAMETER}}
  - match: '(?=\{)'
    pop: true

  # For completeness sake we have
  #   tex.def.group
  #   tex.def.group/
  #   tex.def.group*/
  #   tex.def.groups*/
  # although we only need one or two of these. It's nice and fairly easy to
  # provide them all though, so why not.
  tex.def.group:
  - match: '\{'
    push: tex.def.group.core/

  tex.def.group/:
  - match: '\{'
    set: tex.def.group.core/

  tex.def.group*/:
  - include: tex.def.group/
  - match: '(?=[^\s\{])'
    pop: true

  tex.def.groups*/:
  - include: tex.def.group
  - match: '(?=[^\s\{])'
    pop: true

  tex.def.group.core/:
  - meta_scope: {{@TEX_GROUP}}
  - match: '\}'
    pop: true
  - match: '\#[1-9]'
    scope: {{@TEX_PARAMETER}}
  # We need to make sure to handle nested groups {...} ourselves before main
  # does, so that we can highlight parameters '#n'. Thus we 'include'
  # tex.def.group just before 'include'-ing main.
  - include: tex.def.group
  - include: main

# -----------------------------------------------------------------------------
# LUA
# -----------------------------------------------------------------------------
  lua:
  - include: lua.inline
  - include: lua.block

  lua.inline:
  - match: '\\(directlua|ctxlua)\b'
    scope: {{@CONTROL_WORD}}
    push: lua.group/

  lua.block:
  - match: '(\\start)(lua(code)?)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    # The '(\1)' references the first capture group of the match below it on
    # the stack (so in this case, it will simply refer to 'lua' or 'luacode').
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: lua.main

  lua.main:
  - include: lua.group
  - include: lua.ConTeXt
  # This bit is where we include the default Lua syntax highlighting that
  # Sublime Text provides.
  - include: 'Packages/Lua/Lua.sublime-syntax'

  lua.ConTeXt:
  - match: '\b{{lua_context_functions}}\b'
    scope: {{@LUA_CONTEXT_FUNCTION}}

  lua.group:
  - match: '\{'
    push: lua.group.core/

  lua.group/:
  - match: '\{'
    set: lua.group.core/

  lua.group*/:
  - include: lua.group/
  - match: '(?=[^\s\{])'
    pop: true

  lua.groups*/:
  - include: lua.group
  - match: '(?=[^\s\{])'
    pop: true

  lua.group.core/:
  - meta_scope: {{@LUA_GROUP}}
  - match: '\}'
    pop: true
  - include: lua.main

# -----------------------------------------------------------------------------
# TIKZ
# -----------------------------------------------------------------------------
# For the moment, I've commented this section out (which doesn't break the
# line '- include: tikz' inside the main context, it just silently fails). It
# could do with some work.
  # tikz:
  # - include: tikz.block
  # - include: tikz.inline

  # tikz.block:
  # - match: '\\start(tikzpicture)\b'
  #   scope: entity
  #   push: [
  #     tikz.block.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.block.main/:
  # - match: '\\stop(\1)\b'
  #   scope: entity
  #   pop: true
  # - include: tikz.core

  # tikz.inline:
  # - match: '\\tikz\b'
  #   scope: support.function
  #   push: [
  #     tikz.inline.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.inline.main/:
  # - match: '(?<=;)'
  #   pop: true
  # - include: tikz.core

  # tikz.core:
  # - include: tikz.scope
  # - include: tikz.foreach
  # - include: tikz.draw
  # - include: main

  # tikz.scope:
  # - match: '\\start(scope)\b'
  #   scope: entity
  #   push: [
  #     tikz.scope.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.scope.main/:
  # - match: '\\stop(\1)\b'
  #   scope: entity
  #   pop: true
  # - include: tikz.core

  # tikz.foreach:
  # - match: '\\foreach\b'
  #   scope: keyword
  #   push: [
  #     tikz.foreach.loop/,
  #     tikz.foreach.iterable/,
  #     tikz.foreach.variables/,
  #   ]

  # tikz.foreach.variables/:
  # - match: '\bin\b'
  #   scope: keyword
  #   pop: true
  # - match: '\\[a-zA-Z]+'
  #   scope: support.function

  # tikz.foreach.iterable/:
  # - match: '\\[a-zA-Z]+'
  #   scope: support.function
  #   pop: true
  # - match: '\{'
  #   set:
  #   - match: '\}'
  #     pop: true
  #   - match: '\.{3}'
  #   - match: '/'
  #   - include: tikz.math_expr
  #   - include: main

  # tikz.foreach.loop/:
  # - match: '\{'
  #   set:
  #   - match: '\}'
  #     pop: true
  #   - include: tikz.core
  # - match: '(?=\\{{tikz_draw_cmd}}\b)'
  #   set: tikz.inline.main/

  # tikz.draw:
  # - match: '\\{{tikz_draw_cmd}}\b'
  #   scope: support.function
  #   push: [
  #     tikz.draw.main/,
  #     tikz.lists*/,
  #   ]

  # tikz.draw.main/:
  # - match: ';'
  #   pop: true
  # - match: '(\+{1,2})?\s*\('
  #   captures:
  #     '1': keyword
  #   push:
  #   - match: '\)'
  #     pop: true
  #   - include: tikz.math_expr
  #   - include: main
  # - match: '{{tikz_path_op}}'
  #   push: [
  #     default.group*/,
  #     tikz.lists*/,
  #   ]

  # tikz.list/:
  # - match: '\['
  #   set:
  #   - match: '\]'
  #     pop: true
  #   - match: '([a-zA-Z]+(?:[\sa-zA-Z])*)\s*([<>]?=)'
  #     captures:
  #       '1': variable.parameter
  #       '2': keyword
  #     push:
  #     - match: '(?=[,\]])'
  #       pop: true
  #     - include: tikz.math_expr
  #     - include: main
  #   - include: main

  # tikz.list*/:
  # - match: '(?=[\[])'
  #   set: tikz.list/
  # - match: '(?=[^\s\[])'
  #   pop: true

  # tikz.lists*/:
  # - match: '(?=[\[])'
  #   push: tikz.list/
  # - match: '(?=[^\s\[])'
  #   pop: true

  # tikz.math_expr:
  # - match: '[\+\-\/\*]'
  #   scope: keyword
  # - match: '{{uns_number}}'
  #   scope: constant.numeric

# -----------------------------------------------------------------------------
# MATH
# -----------------------------------------------------------------------------
  math:
  # It is important that math.display comes before math.inline, so that '$$'
  # gets interpreted as beginning TeX-style display math mode instead of
  # entering and immediately exiting TeX-style inline math mode. That said,
  # you really shouldn't be using $$...$$ (TeX-style display math) in ConTeXt.
  - include: math.displays
  - include: math.display
  - include: math.inline

  math.inline:
  - match: '\\(m|math|mathematics)\b'
    scope: {{@CONTROL_WORD}}
    push: math.group/
  - match: '(\$)'
    scope: {{@MATH_TOGGLE}}
    push:
    - match: '(\1)'
      scope: {{@MATH_TOGGLE}}
      pop: true
    - include: math.main

  math.display:
  - match: '(\\start)(formula)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: math.main
  - match: '(\$\$)'
    scope: {{@MATH_TOGGLE}}
    push:
    - match: '(\1)'
      scope: {{@MATH_TOGGLE}}
      pop: true
    - include: math.main

  math.displays:
  - match: '(\\start)(formulas)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: math.display

  math.main:
  # This context is the main workhorse of math highlighting.
  - include: math.align
  - include: math.cases
  - include: math.group
  - include: math.substack
  - include: math.text
  # Sure, why not include lua.inline, it can be nice to properly highlight an
  # inline Lua call.
  - include: lua.inline
  - include: math.default

  math.default:
  - match: '{{number}}'
    scope: {{@NUMBER}}
  - match: '\\[a-zA-Z]+'
    scope: {{@MATH_CONTROL_WORD}}
  - match: '\\[^a-zA-Z]'
    scope: {{@MATH_CONTROL_SYMBOL}}
  - include: default
    # This match is what makes plain text within math mode highlight like a
    # string
  - match: '.'
    scope: {{@MATH_TEXT}}

  math.text:
  - match: '\\text\b'
    scope: {{@CONTROL_WORD}}
    push: default.group/
  - match: '(\\start)(intertext)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: main

  math.substack:
  - match: '(\\start)(substack)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - match: '\\NR\b'
      scope: {{@NEW_ROW}}
    - include: math.main

  math.cases:
  # This context is setup to match \startmathcases[optional square brackets,
  # pass some options] ... \stopmathcases, and between them it will match
  # rows: so highlight the first bit of a row '\NC ...' as math. The second bit
  # can be either '\NC ... \NR' or '\MC ... \NR', which will be highlighted as
  # text and math respectively (NC = new column and MC = math column).
  - match: '(\\start)(mathcases)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: [
      math.cases.core/,
      default.list*/,
    ]

  math.cases.core/:
  - match: '(\\stop)(\2)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
    pop: true
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
    push: [
      math.cases.right/,
      math.cases.left/,
    ]

  math.cases.left/:
  - match: '(?=\\[NM]C\b)'
    pop: true
  - include: math.main

  math.cases.right/:
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
    set:
    - include: math.cases.right.core/
    - include: main
  - match: '\\MC\b'
    scope: {{@NEW_MATH_COLUMN}}
    set:
    - include: math.cases.right.core/
    - include: math.main

  math.cases.right.core/:
  - match: '\\NR\b'
    scope: {{@NEW_ROW}}
    pop: true

  math.align:
  - match: '(\\start)(align|mathalignment)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: [
      math.align.core/,
      default.list*/,
    ]

  math.align.core/:
  - match: '(\\stop)(\2)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
    pop: true
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
  - match: '\\NR\b'
    scope: {{@NEW_ROW}}
  - include: math.main

  math.group:
  - match: '\{'
    push: math.group.core/

  math.group/:
  - match: '\{'
    set: math.group.core/

  math.group*/:
  - include: math.group/
  - match: '(?=[^\s\{])'
    pop: true

  math.groups*/:
  - include: math.group
  - match: '(?=[^\s\{])'
    pop: true

  math.group.core/:
  - meta_scope: {{@MATH_GROUP}}
  - match: '\}'
    pop: true
  - include: math.main

# -----------------------------------------------------------------------------
# CONTEXT
# -----------------------------------------------------------------------------
# This section is devoted to matching syntax unique to ConTeXt
  ConTeXt:
  - include: ConTeXt.usemodule
  - include: ConTeXt.defs
  - include: ConTeXt.tables
  - include: ConTeXt.itemize
  - include: ConTeXt.default

  ConTeXt.default:
  - include: ConTeXt.default.start_stop
  - include: ConTeXt.default.define
  - include: ConTeXt.default.setup

  ConTeXt.default.define:
  - match: '(\\define)([a-zA-Z]+)'
    captures:
      '1': {{@DEFINE}}
      '2': {{@DEFINE_NAME}}
    push: default.lists*/

  ConTeXt.default.setup:
  - match: '(\\setup)([a-zA-Z]+)'
    captures:
      '1': {{@SETUP}}
      '2': {{@SETUP_NAME}}
    push: default.lists*/

  ConTeXt.default.start_stop:
  - match: '(\\start)([a-zA-Z]+)'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: default.lists*/
  - match: '(\\stop)([a-zA-Z]+)'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}

  ConTeXt.usemodule:
  - match: '\\usemodule\b'
    scope: {{@CONTEXT_KEYWORD}}
    push: ConTeXt.usemodule.list*/

  ConTeXt.usemodule.list*/:
  - match: '\['
    set: ConTeXt.usemodule.list.core/
  - match: '(?=[^\s\[])'
    pop: true

  ConTeXt.usemodule.list.core/:
  - meta_scope: {{@LIST}}
  - match: '\]'
    pop: true
  - match: '[a-zA-Z]+'
    scope: {{@CONTEXT_MODULE}}

  ConTeXt.defs:
  # Match some ConTeXt specific variations of '\def'
  - include: ConTeXt.texdef
  - include: ConTeXt.define

  ConTeXt.texdef:
  - match: '(\\start)(texdefinition)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: [
      ConTeXt.texdef.main/,
      ConTeXt.texdef.arguments*/,
      ConTeXt.texdef.name/,
      ConTeXt.texdef.prefixes*/,
    ]

  ConTeXt.texdef.prefixes*/:
  - match: '\b(global|(un)?expanded)\b'
    scope: {{@TEX_DEF_PREFIX}}
  - match: '(?=[^\s])'
    pop: true

  ConTeXt.texdef.name/:
  - match: '[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
    pop: true

  ConTeXt.texdef.arguments*/:
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: {{@TEX_PARAMETER}}
  - match: '(?=[^\s])'
    pop: true

  ConTeXt.texdef.main/:
  # Inside a 'texdefinition', ConTeXt treats comments differently - now '%%'
  # denotes a comment, and '%' is just a literal percentage sign
  - meta_include_prototype: false
  - match: '(\\stop)(\2)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
    pop: true
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: {{@TEX_PARAMETER}}
  - include: ConTeXt.texdef.comment
  - include: ConTeXt.texdef.group
  - include: main

  ConTeXt.texdef.comment:
  - meta_include_prototype: false
  - match: '\%\s*\%.*'
    scope: {{@COMMENT}}

  ConTeXt.texdef.group:
  - meta_include_prototype: false
  - match: '\{'
    push: ConTeXt.texdef.group.core/

  ConTeXt.texdef.group.core/:
  - meta_include_prototype: false
  - meta_scope: {{@TEX_GROUP}}
  - match: '\}'
    pop: true
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: {{@TEX_PARAMETER}}
  - include: ConTeXt.texdef.comment
  # Just like with tex.def.group.core/, we have to make sure to intercept any
  # groups {...} before main gets to them, if we want to highlight parameters
  # '#n' inside nested groups
  - include: ConTeXt.texdef.group
  - include: main

  ConTeXt.define:
  - match: '\\define\b'
    scope: {{@TEX_DEF}}
    push: [
      tex.def.group/,
      tex.def.assignable/,
      ConTeXt.count.list*/,
    ]

  ConTeXt.itemize:
  - match: '(\\start)(itemize)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: default.lists*/
  - match: '(\\stop)(itemize)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
  - match: '\\(item|head)\b'
    scope: {{@ITEM}}

  ConTeXt.tables:
  # ConTeXt has many ways to create tables (for historical reasons), some of
  # which are simply deprecated and others just have pros and cons. In fact
  # 'table's are deprecated, but I didn't know that before writing some (now
  # rather messy) support for them, so it's here now.
  #   Also included so far (with very very basic support) is the 'TABLE' way of
  # doings tables.
  - include: ConTeXt.table
  - include: ConTeXt.TABLE

  ConTeXt.TABLE:
  - match: '(\\b)(TABLE|T[RD])\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: default.lists*/
  - match: '(\\e)(TABLE|T[RD])\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}

  ConTeXt.table:
  - match: '(\\start)(table)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: ConTeXt.table.spec.list*/
  - match: '(\\stop)(table)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
  - match: '\\[HV]L\b'
    scope: {{@NEW_LINE}}
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
  - match: '\\[FMLSNA]R\b'
    scope: {{@NEW_ROW}}
  - match: '\\Use\b'
    scope: {{@CONTROL_WORD}}
    push: [
      default.group/,
      ConTeXt.table.spec.list/,
      ConTeXt.count.group/,
    ]
  - match: '\\(REF|ReFormat)\b'
    scope: {{@CONTROL_WORD}}
    push: [
      default.group/,
      ConTeXt.table.spec.list/,
    ]

  ConTeXt.count.group/:
  - match: '\{'
    set: ConTeXt.count.group.core/

  ConTeXt.count.group.core/:
  - match: '\}'
    pop: true
  - match: '{{uns_int}}'
    scope: {{@NUMBER}}

  ConTeXt.count.list*/:
  - match: '\['
    set: ConTeXt.count.list.core/
  - match: '(?=[^\s\[])'
    pop: true

  ConTeXt.count.list.core/:
  - match: '\]'
    pop: true
  - match: '{{uns_int}}'
    scope: {{@NUMBER}}

  ConTeXt.table.spec.list:
  - match: '\['
    push: ConTeXt.table.spec.list.core/

  ConTeXt.table.spec.list/:
  - match: '\['
    set: ConTeXt.table.spec.list.core/

  ConTeXt.table.spec.list*/:
  - include: ConTeXt.table.spec.list/
  - match: '(?=[^\s\[])'
    pop: true

  ConTeXt.table.spec.lists*/:
  - include: ConTeXt.table.spec.list
  - match: '(?=[^\s\[])'
    pop: true

  ConTeXt.table.spec.list.core/:
  - meta_scope: {{@TABLE_LIST}}
  - match: '\]'
    pop: true
  - include: ConTeXt.table.spec
  - include: main

  ConTeXt.table.spec:
  - match: '([lcrx])?([wp])\(({{number}})\)'
    captures:
      '1': {{@TABLE_ALIGNMENT}}
      '2': {{@TABLE_WIDTH}}
      '3': {{@NUMBER}}
  - match: '[lcr]'
    scope: {{@TABLE_ALIGNMENT}}
  - match: '[BISRT]'
    scope: {{@TABLE_FONT}}
  - match: '[f]'
    scope: {{@TABLE_FONT}}
    push: default.group/
  - match: '[mM]'
    scope: {{@TABLE_MATH}}
  - match: '[nN]{{uns_int}}\.{{uns_int}} '
    scope: {{@TABLE_NUM_ALIGN}}
  - match: '[qQ]{{uns_int}}\,{{uns_int}} '
    scope: {{@TABLE_NUM_ALIGN}}
  - match: '([soijk])(\{{{uns_int}}\}|\({{number}}{{unit}}\)|\d)'
    captures:
      '1': {{@TABLE_SPACE}}
      '2': {{@NUMBER}}

# -----------------------------------------------------------------------------
# DEFAULT
# -----------------------------------------------------------------------------
# This section applies matches very broadly, and only gets the chance to match
# stuff if no other match has been found.
  default:
  - include: default.if
  - include: default.group
  - include: default.control_word
  - include: default.control_symbol

  default.if:
  - match: '\\(if[a-zA-Z]+|else|fi)\b'
    scope: {{@KEYWORD}}

  default.control_symbol:
  - match: '\\[^a-zA-Z]'
    scope: {{@CONTROL_SYMBOL}}

  default.control_word:
  - match: '\\[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
    push: default.lists*/

  default.group:
  - match: '\{'
    push: default.group.core/

  default.group/:
  - match: '\{'
    set: default.group.core/

  default.group*/:
  - include: default.group/
  - match: '(?=[^\s\{])'
    pop: true

  default.groups*/:
  - include: default.group
  - match: '(?=[^\s\{])'
    pop: true

  default.group.core/:
  - meta_scope: {{@TEX_GROUP}}
  - match: '\}'
    pop: true
  - include: main

  # I've taken to calling these 'lists', what they are is simply something
  # like '[...]'. That is, a square-bracket delimited thing. Inside the list,
  # we do some very simple matches, e.g. take care of key=value style syntax,
  # and finally (this bit is debatable) colour any leftover plain text as a
  # string.
  default.list:
  - match: '\['
    push: default.list.core/

  default.list/:
  - match: '\['
    set: default.list.core/

  default.list*/:
  - include: default.list/
  - match: '(?=[^\s\[])'
    pop: true

  default.lists*/:
  - include: default.list
  - match: '(?=[^\s\[])'
    pop: true

  default.list.core/:
  - meta_scope: {{@LIST}}
  - match: '\]'
    pop: true
  - match: '\,'
  - match: '{{number}}(\s*{{unit}})?'
    scope: {{@NUMBER}}
  - match: '([a-zA-Z]+)(=)'
    captures:
      '1': {{@KEY}}
      '2': {{@EQUALS}}
  - match: ':'
    scope: {{@COLON}}
  - include: main
  - match: '.'
    scope: {{@LIST_TEXT}}
