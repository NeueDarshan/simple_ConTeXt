%YAML 1.2
---
# See http://www.sublimetext.com/docs/3/syntax.html for a good, albeit
# incomplete, explanation of how this syntax works.
name: ConTeXt
file_extensions: tex
scope: text.tex.context
# -----------------------------------------------------------------------------
# VARIABLES
# -----------------------------------------------------------------------------
# Variables are nice! In addition to the ones here, we also have some variables
# in syntax_pre_process.json - to reference them, simply type {{@var_name}}.
# Then the python preprocessor will replace them with the corresponding values.
variables:
  unit: '(pt|pc|in|bp|cm|mm|cc|sp|em|ex)' # valid TeX units
  uns_int: '\d+'
  uns_real: '(\d+\.\d*|\d*\.\d+)'
  uns_number: '({{uns_real}}|{{uns_int}})'
  number: '[\+\-]*{{uns_number}}'
  lua_context_functions: '(tex\.s?print)|context'
  tikz_keywords: '(in|at|grid|edge|node|rectangle|cycle|coordinate|decorate|controls|child)'
  tikz_math_operator: '([\+\-\*\/\^!><\?:]|[=><!]=|&&|\|\|)'
  tikz_math_function: '(abs|acos|add|and|array|asin|atan|atan2|bin|ceil|cos|cosec|cosh|cot|deg|depth|div|divide|e|equal|factorial|false|floor|frac|gcd|greater|height|hex|Hex|int|ifthenelse|iseven|isodd|isprime|less|ln|log10|log2|max|min|mod|Mod|multiply|neg|not|notequal|notgreater|notless|oct|or|pi|pow|rad|rand|random|real|rnd|round|sec|sin|sinh|sqrt|subtract|tan|tanh|true|veclen|width)'

# -----------------------------------------------------------------------------
# MAIN
# -----------------------------------------------------------------------------
# A note on the naming convention I've been using for contexts:
#   * if it ends in a '/' then it pops off when (and only when) it finds a
#       match (what a 'match' means will depend on the particular context, but
#       e.g. 'group/' is looking to match something like '{...}')
#   * ending in '*/' means the same as '/', except that it will pop off if it
#       can't find any match - it is optional. (I wanted to use '?' for this
#       purpose, but it is not allowed in a context name)
#   * otherwise it never pops, it just remains at the current level of scope -
#       generally these are the ones intended for 'include'-ing (which you can
#       think of as just 'copy-paste'-ing that contexts code wherever the
#       include statement occurs)
# Oh, one more note: the characters that can be used in a context name are
# quite generous - you can use more of the ASCII character set than you'd
# expect! So I've been using '.' to pretend that I have namespaces, but don't
# be fooled, there is only the global namespace (as far as I know).
contexts:
  main:
  - include: TeX
  - include: lua
  - include: TikZ
  - include: math
  - include: ConTeXt
  - include: default

  prototype:
  - include: comments

  comments:
  # Because these matches are applied one line at a time, we can use this very
  # simple regex instead of something like '\%.*?$'.
  - match: '\%.*'
    scope: {{@COMMENT}}

# -----------------------------------------------------------------------------
# TEX
# -----------------------------------------------------------------------------
  TeX:
  - include: TeX.def

  TeX.def:
  - match: '(\\)([egx]?)(def)\b'
    captures:
      '1': {{@TEX_DEF}}
      '2': {{@TEX_DEF_PREFIX}}
      '3': {{@TEX_DEF}}
    # Things are pushed onto the stack in the order they are written, so that
    # after this 'push', 'TeX.def.assignable/' will be on top of the stack,
    # with 'TeX.def.parameters*/' just below it and 'TeX.def.group/' below
    # that.
    push: [
      TeX.def.group/,
      TeX.def.parameters*/,
      TeX.def.assignable/,
    ]

  TeX.def.assignable/:
  # although usually you '\def' a control word, it is also possible to '\def' a
  # control symbol or an active character
  - match: '\\[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
    pop: true
  - match: '\\[^a-zA-Z]'
    scope: {{@CONTROL_SYMBOL}}
    pop: true
  - match: '[^\s]'
    scope: {{@ACTIVE_CHARACTER}}
    pop: true

  TeX.def.parameters*/:
  - match: '\#([1-9]|(?=\{))'
    scope: {{@TEX_PARAMETER}}
  - match: '(?=\{)'
    pop: true

  # For completeness sake we have
  #   TeX.def.group
  #   TeX.def.group/
  #   TeX.def.group*/
  #   TeX.def.groups*/
  # although we only need one or two of these. It's nice and fairly easy to
  # provide them all though, so why not.
  TeX.def.group:
  - match: '\{'
    push: TeX.def.group.core/

  TeX.def.group/:
  - match: '\{'
    set: TeX.def.group.core/

  TeX.def.group*/:
  - include: TeX.def.group/
  - match: '(?=[^\s\{])'
    pop: true

  TeX.def.groups*/:
  - include: TeX.def.group
  - match: '(?=[^\s\{])'
    pop: true

  TeX.def.group.core/:
  - meta_scope: {{@TEX_GROUP}}
  - match: '\}'
    pop: true
  - match: '\#[1-9]'
    scope: {{@TEX_PARAMETER}}
  # We need to make sure to handle nested groups {...} ourselves before main
  # does, so that we can highlight parameters '#n'. Thus we 'include'
  # TeX.def.group just before 'include'-ing main.
  - include: TeX.def.group
  - include: main

# -----------------------------------------------------------------------------
# LUA
# -----------------------------------------------------------------------------
  lua:
  - include: lua.inline
  - include: lua.block

  lua.inline:
  - match: '\\(directlua|ctxlua)\b'
    scope: {{@CONTROL_WORD}}
    push: lua.group/

  lua.block:
  - match: '(\\start)(lua(code)?)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    # The '(\1)' references the first capture group of the match below it on
    # the stack (so in this case, it will simply refer to 'lua' or 'luacode').
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: lua.main

  lua.main:
  - include: lua.group
  - include: lua.ConTeXt
  # This bit is where we include the default Lua syntax highlighting that
  # Sublime Text provides.
  - include: 'Packages/Lua/Lua.sublime-syntax'

  lua.ConTeXt:
  - match: '\b{{lua_context_functions}}\b'
    scope: {{@LUA_CONTEXT_FUNCTION}}

  lua.group:
  - match: '\{'
    push: lua.group.core/

  lua.group/:
  - match: '\{'
    set: lua.group.core/

  lua.group*/:
  - include: lua.group/
  - match: '(?=[^\s\{])'
    pop: true

  lua.groups*/:
  - include: lua.group
  - match: '(?=[^\s\{])'
    pop: true

  lua.group.core/:
  - meta_scope: {{@LUA_GROUP}}
  - match: '\}'
    pop: true
  - include: lua.main

# -----------------------------------------------------------------------------
# TIKZ
# -----------------------------------------------------------------------------
  TikZ:
  - include: TikZ.block
  - include: TikZ.inline

  TikZ.block:
  - match: '(\\start)(tikzpicture)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: [
      TikZ.block.core/,
      TikZ.lists*/,
    ]

  TikZ.block.core/:
  - meta_scope: {{@TIKZ_SCOPE}}
  - match: '(\\stop)(\2)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
    pop: true
  - include: TikZ.main

  TikZ.inline:
  - match: '\\tikz\b'
    scope: {{@CONTROL_WORD}}
    push: [
      TikZ.inline.core/,
      TikZ.lists*/,
    ]

  TikZ.inline.core/:
  - meta_scope: {{@TIKZ_SCOPE}}
  - match: ';'
    scope: {{@TIKZ_SEMI_COLON}}
    pop: true
  - include: TikZ.main

  TikZ.main:
  - include: TikZ.keyword
  - include: TikZ.scope
  - include: TikZ.group
  - include: TikZ.list
  - include: TikZ.calc
  - include: TeX
  - include: lua
  - include: math
  - include: ConTeXt
  - include: TikZ.default

  TikZ.calc:
  - match: '\(\$'
    scope: {{@TIKZ_CALC_TOGGLE}}
    push: TikZ.calc.core/

  TikZ.calc.core/:
  - match: '\$\)'
    scope: {{@TIKZ_CALC_TOGGLE}}
    pop: true
  - match: '{{tikz_math_operator}}'
    scope:  {{@TIKZ_MATH_OPERATOR}}
  - match: '\b{{tikz_math_function}}\b'
    scope:  {{@TIKZ_MATH_FUNCTION}}
  - match: '{{number}}\s*{{unit}}?'
    scope: {{@NUMBER}}

  TikZ.keyword:
  - match: '\\foreach\b'
    scope: {{@KEYWORD}}
  - match: '\b{{tikz_keywords}}\b'
    scope: {{@KEYWORD}}

  TikZ.scope:
  - match: '(\\start)(scope)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
  - match: '(\\stop)(scope)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}

  TikZ.default:
  - match: '{{number}}\s*{{unit}}?'
    scope: {{@NUMBER}}
  - match: '\\[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
  - match: '\\[^a-zA-Z]'
    scope: {{@CONTROL_SYMBOL}}
  - match: ';'
    scope: {{@TIKZ_SEMI_COLON}}

  TikZ.group:
  - match: '\{'
    push: TikZ.group.core/

  TikZ.group.core/:
  - meta_scope: {{@TIKZ_GROUP}}
  - include: TikZ.main
  - match: '\}'
    pop: true

  TikZ.list:
  - match: '\['
    push: TikZ.list.core/

  TikZ.lists*/:
  - include: TikZ.list
  - match: '(?=[^\s\[])'
    pop: true

  TikZ.list.core/:
  - meta_scope: {{@TIKZ_LIST}}
  - match: '\]'
    pop: true
  - include: TikZ.list.group
  - include: TikZ.options.core

  TikZ.list.group:
  - match: '\['
    push: TikZ.list.group.core/

  TikZ.list.group.core/:
  - meta_scope: {{@TIKZ_GROUP}}
  - match: '\]'
    pop: true
  - include: TikZ.options.core

  TikZ.options.core:
  - match: '([a-zA-Z][a-zA-Z0-9\s\./\->]*)(=)'
    captures:
      '1': {{@KEY}}
      '2': {{@EQUALS}}
  - match: '{{number}}\s*{{unit}}?'
    scope: {{@NUMBER}}
  - match: '\\[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
  - match: '\\[^a-zA-Z]'
    scope: {{@CONTROL_SYMBOL}}
  - include: math

# -----------------------------------------------------------------------------
# MATH
# -----------------------------------------------------------------------------
  math:
  # It is important that math.display comes before math.inline, so that '$$'
  # gets interpreted as beginning TeX-style display math mode instead of
  # entering and immediately exiting TeX-style inline math mode. That said,
  # you really shouldn't be using $$...$$ (TeX-style display math) in ConTeXt.
  - include: math.displays
  - include: math.display
  - include: math.inline

  math.inline:
  - match: '\\(m|math|mathematics)\b'
    scope: {{@CONTROL_WORD}}
    push: math.group/
  - match: '(\$)'
    scope: {{@MATH_TOGGLE}}
    push:
    - match: '(\1)'
      scope: {{@MATH_TOGGLE}}
      pop: true
    - include: math.main

  math.display:
  - match: '(\\start)(formula)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: math.main
  - match: '(\$\$)'
    scope: {{@MATH_TOGGLE}}
    push:
    - match: '(\1)'
      scope: {{@MATH_TOGGLE}}
      pop: true
    - include: math.main

  math.displays:
  - match: '(\\start)(formulas)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: math.display

  math.main:
  # This context is the main workhorse of math highlighting.
  - include: math.align
  - include: math.cases
  - include: math.group
  - include: math.substack
  - include: math.text
  # Sure, why not include lua.inline, it can be nice to properly highlight an
  # inline Lua call.
  - include: lua.inline
  - include: math.default

  math.default:
  - match: '{{number}}'
    scope: {{@NUMBER}}
  - match: '\\[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
  - match: '\\[^a-zA-Z]'
    scope: {{@CONTROL_SYMBOL}}
  - include: default
    # This match is what makes plain text within math mode highlight like a
    # string
  - match: '.'
    scope: {{@MATH_TEXT}}

  math.text:
  - match: '\\text\b'
    scope: {{@CONTROL_WORD}}
    push: default.group/
  - match: '(\\start)(intertext)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - include: main

  math.substack:
  - match: '(\\start)(substack)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push:
    - match: '(\\stop)(\2)\b'
      captures:
        '1': {{@STOP_SCOPE}}
        '2': {{@SCOPE_NAME}}
      pop: true
    - match: '\\NR\b'
      scope: {{@NEW_ROW}}
    - include: math.main

  math.cases:
  # This context is setup to match \startmathcases[optional square brackets,
  # pass some options] ... \stopmathcases, and between them it will match
  # rows: so highlight the first bit of a row '\NC ...' as math. The second bit
  # can be either '\NC ... \NR' or '\MC ... \NR', which will be highlighted as
  # text and math respectively (NC = new column and MC = math column).
  - match: '(\\start)(mathcases)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: [
      math.cases.core/,
      default.list*/,
    ]

  math.cases.core/:
  - match: '(\\stop)(\2)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
    pop: true
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
    push: [
      math.cases.right/,
      math.cases.left/,
    ]

  math.cases.left/:
  - match: '(?=\\[NM]C\b)'
    pop: true
  - include: math.main

  math.cases.right/:
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
    set:
    - include: math.cases.right.core/
    - include: main
  - match: '\\MC\b'
    scope: {{@NEW_COLUMN}}
    set:
    - include: math.cases.right.core/
    - include: math.main

  math.cases.right.core/:
  - match: '\\NR\b'
    scope: {{@NEW_ROW}}
    pop: true

  math.align:
  - match: '(\\start)(align|mathalignment)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: [
      math.align.core/,
      default.list*/,
    ]

  math.align.core/:
  - match: '(\\stop)(\2)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
    pop: true
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
  - match: '\\NR\b'
    scope: {{@NEW_ROW}}
  - include: math.main

  math.group:
  - match: '\{'
    push: math.group.core/

  math.group/:
  - match: '\{'
    set: math.group.core/

  math.group*/:
  - include: math.group/
  - match: '(?=[^\s\{])'
    pop: true

  math.groups*/:
  - include: math.group
  - match: '(?=[^\s\{])'
    pop: true

  math.group.core/:
  - meta_scope: {{@MATH_GROUP}}
  - match: '\}'
    pop: true
  - include: math.main

# -----------------------------------------------------------------------------
# CONTEXT
# -----------------------------------------------------------------------------
# This section is devoted to matching syntax unique to ConTeXt
  ConTeXt:
  - include: ConTeXt.usemodule
  - include: ConTeXt.defs
  - include: ConTeXt.tables
  - include: ConTeXt.itemize
  - include: ConTeXt.default

  ConTeXt.default:
  - include: ConTeXt.default.start_stop
  - include: ConTeXt.default.define
  - include: ConTeXt.default.setup
  - include: ConTeXt.default.place

  ConTeXt.default.define:
  - match: '(\\define)([a-zA-Z]+)'
    captures:
      '1': {{@DEFINE}}
      '2': {{@DEFINE_NAME}}
    push: default.lists*/

  ConTeXt.default.setup:
  - match: '(\\setup)([a-zA-Z]+)'
    captures:
      '1': {{@SETUP}}
      '2': {{@SETUP_NAME}}
    push: default.lists*/

  ConTeXt.default.place:
  - match: '(\\place)([a-zA-Z]+)'
    captures:
      '1': {{@PLACE}}
      '2': {{@PLACE_NAME}}
    push: default.lists*/

  ConTeXt.default.start_stop:
  - match: '(\\start)([a-zA-Z]+)'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: default.lists*/
  - match: '(\\stop)([a-zA-Z]+)'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}

  ConTeXt.usemodule:
  - match: '\\usemodule\b'
    scope: {{@USE_MODULE}}
    push: ConTeXt.usemodule.list*/

  ConTeXt.usemodule.list*/:
  - match: '\['
    set: ConTeXt.usemodule.list.core/
  - match: '(?=[^\s\[])'
    pop: true

  ConTeXt.usemodule.list.core/:
  - meta_scope: {{@LIST}}
  - match: '\]'
    pop: true
  - match: '[a-zA-Z]+'
    scope: {{@MODULE_NAME}}

  ConTeXt.defs:
  # Match some ConTeXt specific variations of '\def'
  - include: ConTeXt.texdef
  - include: ConTeXt.define

  ConTeXt.texdef:
  - match: '(\\start)(texdefinition)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: [
      ConTeXt.texdef.main/,
      ConTeXt.texdef.arguments*/,
      ConTeXt.texdef.name/,
      ConTeXt.texdef.prefixes*/,
    ]

  ConTeXt.texdef.prefixes*/:
  - match: '\b(global|(un)?expanded)\b'
    scope: {{@TEX_DEF_PREFIX}}
  - match: '(?=[^\s])'
    pop: true

  ConTeXt.texdef.name/:
  - match: '[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
    pop: true

  ConTeXt.texdef.arguments*/:
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: {{@TEX_PARAMETER}}
  - match: '(?=[^\s])'
    pop: true

  ConTeXt.texdef.main/:
  # Inside a 'texdefinition', ConTeXt treats comments differently - now '%%'
  # denotes a comment, and '%' is just a literal percentage sign
  - meta_include_prototype: false
  - match: '(\\stop)(\2)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
    pop: true
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: {{@TEX_PARAMETER}}
  - include: ConTeXt.texdef.comment
  - include: ConTeXt.texdef.group
  - include: main

  ConTeXt.texdef.comment:
  - meta_include_prototype: false
  - match: '\%\s*\%.*'
    scope: {{@COMMENT}}

  ConTeXt.texdef.group:
  - meta_include_prototype: false
  - match: '\{'
    push: ConTeXt.texdef.group.core/

  ConTeXt.texdef.group.core/:
  - meta_include_prototype: false
  - meta_scope: {{@TEX_GROUP}}
  - match: '\}'
    pop: true
  - match: '\#([1-9]|[a-zA-Z]+)'
    scope: {{@TEX_PARAMETER}}
  - include: ConTeXt.texdef.comment
  # Just like with TeX.def.group.core/, we have to make sure to intercept any
  # groups {...} before main gets to them, if we want to highlight parameters
  # '#n' inside nested groups
  - include: ConTeXt.texdef.group
  - include: main

  ConTeXt.define:
  - match: '\\define\b'
    scope: {{@TEX_DEF}}
    push: [
      TeX.def.group/,
      TeX.def.assignable/,
      ConTeXt.count.list*/,
    ]

  ConTeXt.itemize:
  - match: '(\\start)(itemize)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: default.lists*/
  - match: '(\\stop)(itemize)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
  - match: '\\(item|head)\b'
    scope: {{@ITEM}}

  ConTeXt.tables:
  # ConTeXt has many ways to create tables (for historical reasons), some of
  # which are simply deprecated and others just have pros and cons. In fact
  # 'table's are deprecated, but I didn't know that before writing some (now
  # rather messy) support for them, so it's here now.
  #   Also included so far (with very very basic support) is the 'TABLE' way of
  # doings tables.
  - include: ConTeXt.table
  - include: ConTeXt.TABLE

  ConTeXt.TABLE:
  - match: '(\\b)(TABLE|T[RD])\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: default.lists*/
  - match: '(\\e)(TABLE|T[RD])\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}

  ConTeXt.table:
  - match: '(\\start)(table)\b'
    captures:
      '1': {{@START_SCOPE}}
      '2': {{@SCOPE_NAME}}
    push: ConTeXt.table.spec.list*/
  - match: '(\\stop)(table)\b'
    captures:
      '1': {{@STOP_SCOPE}}
      '2': {{@SCOPE_NAME}}
  - match: '\\[HV]L\b'
    scope: {{@NEW_LINE}}
  - match: '\\NC\b'
    scope: {{@NEW_COLUMN}}
  - match: '\\[FMLSNA]R\b'
    scope: {{@NEW_ROW}}
  - match: '\\Use\b'
    scope: {{@CONTROL_WORD}}
    push: [
      default.group/,
      ConTeXt.table.spec.list/,
      ConTeXt.count.group/,
    ]
  - match: '\\(REF|ReFormat)\b'
    scope: {{@CONTROL_WORD}}
    push: [
      default.group/,
      ConTeXt.table.spec.list/,
    ]

  ConTeXt.count.group/:
  - match: '\{'
    set: ConTeXt.count.group.core/

  ConTeXt.count.group.core/:
  - match: '\}'
    pop: true
  - match: '{{uns_int}}'
    scope: {{@NUMBER}}

  ConTeXt.count.list*/:
  - match: '\['
    set: ConTeXt.count.list.core/
  - match: '(?=[^\s\[])'
    pop: true

  ConTeXt.count.list.core/:
  - match: '\]'
    pop: true
  - match: '{{uns_int}}'
    scope: {{@NUMBER}}

  ConTeXt.table.spec.list/:
  - match: '\['
    set: ConTeXt.table.spec.list.core/

  ConTeXt.table.spec.list*/:
  - include: ConTeXt.table.spec.list/
  - match: '(?=[^\s\[])'
    pop: true

  ConTeXt.table.spec.list.core/:
  - meta_scope: {{@TABLE_LIST}}
  - match: '\]'
    pop: true
  - include: ConTeXt.table.spec
  - include: main

  ConTeXt.table.spec:
  - match: '([lcrx])?([wp])\(({{number}})\)'
    captures:
      '1': {{@TABLE_ALIGNMENT}}
      '2': {{@TABLE_WIDTH}}
      '3': {{@NUMBER}}
  - match: '[lcr]'
    scope: {{@TABLE_ALIGNMENT}}
  - match: '[BISRT]'
    scope: {{@TABLE_FONT}}
  - match: '[f]'
    scope: {{@TABLE_FONT}}
    push: default.group/
  - match: '[mM]'
    scope: {{@TABLE_MATH}}
  - match: '[nN]{{uns_int}}\.{{uns_int}} '
    scope: {{@TABLE_NUM_ALIGN}}
  - match: '[qQ]{{uns_int}}\,{{uns_int}} '
    scope: {{@TABLE_NUM_ALIGN}}
  - match: '([soijk])(\{{{uns_int}}\}|\({{number}}{{unit}}\)|\d)'
    captures:
      '1': {{@TABLE_SPACE}}
      '2': {{@NUMBER}}

# -----------------------------------------------------------------------------
# DEFAULT
# -----------------------------------------------------------------------------
# This section applies matches very broadly, and only gets the chance to match
# stuff if no other match has been found.
  default:
  - include: default.if
  - include: default.group
  - include: default.control_word
  - include: default.control_symbol

  default.if:
  - match: '\\(if[a-zA-Z]*|else|fi)\b'
    scope: {{@KEYWORD}}

  default.control_symbol:
  - match: '\\[^a-zA-Z]'
    scope: {{@CONTROL_SYMBOL}}

  default.control_word:
  - match: '\\[a-zA-Z]+'
    scope: {{@CONTROL_WORD}}
    push: default.lists*/

  default.group:
  - match: '\{'
    push: default.group.core/

  default.group/:
  - match: '\{'
    set: default.group.core/

  default.group*/:
  - include: default.group/
  - match: '(?=[^\s\{])'
    pop: true

  default.groups*/:
  - include: default.group
  - match: '(?=[^\s\{])'
    pop: true

  default.group.core/:
  - meta_scope: {{@TEX_GROUP}}
  - match: '\}'
    pop: true
  - include: main

  # I've taken to calling these 'lists', what they are is simply something
  # like '[...]'. That is, a square-bracket delimited thing. Inside the list,
  # we do some very simple matches, e.g. take care of key=value style syntax,
  # and finally (this bit is debatable) colour any leftover plain text as a
  # string.
  default.list:
  - match: '\['
    push: default.list.core/

  default.list/:
  - match: '\['
    set: default.list.core/

  default.list*/:
  - include: default.list/
  - match: '(?=[^\s\[])'
    pop: true

  default.lists*/:
  - include: default.list
  - match: '(?=[^\s\[])'
    pop: true

  default.list.core/:
  - meta_scope: {{@LIST}}
  - match: '\]'
    pop: true
  - match: '\,'
  - match: '{{number}}(\s*{{unit}})?'
    scope: {{@NUMBER}}
  - match: '([a-zA-Z]+)(=)'
    captures:
      '1': {{@KEY}}
      '2': {{@EQUALS}}
  - match: ':'
    scope: {{@COLON}}
  - include: main
